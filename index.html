<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, viewport-fit=cover">
    <title>Crocker Rook</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Crocker Rook">
    <link rel="apple-touch-icon" href="icon-192.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Teko:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --black-suit: #2d3436;
            --red-suit: #e74c3c;
            --green-suit: #27ae60;
            --yellow-suit: #f39c12;
            --card-back: #3498db;
            --table-color: #0f172a;
            --table-gradient: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
            --border-color: #fbbf24;
            --shadow-color: rgba(0, 0, 0, 0.25);
            --card-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            --card-hover-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --text-primary: #ffffff;
            --text-secondary: #e2e8f0;
            --text-muted: #94a3b8;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --surface: rgba(30, 41, 59, 0.8);
            --surface-hover: rgba(30, 41, 59, 0.9);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--table-gradient);
            color: var(--text-primary);
            margin: 0;
            padding: 0;
            /* overflow: hidden; */ /* Remove to prevent cutoff */
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation;
            min-height: 100dvh;
            min-width: 100dvw;
            position: relative;
        }

        @media (orientation: portrait) {
            /* Portrait mode layout - vertical stack */
            .player-area {
                position: fixed !important;
                width: 100% !important;
                height: auto !important;
                transform: none !important;
            }

            .player-top {
                top: 5% !important;
                left: 0 !important;
                right: 0 !important;
            }

            .player-bottom {
                bottom: 5% !important;
                left: 0 !important;
                right: 0 !important;
            }

            .player-left {
                top: 30% !important;
                left: 0 !important;
                right: 0 !important;
            }

            .player-right {
                top: 50% !important;
                left: 0 !important;
                right: 0 !important;
            }

            .game-board {
                top: 35% !important;
                left: 50% !important;
                transform: translate(-50%, -50%) scale(0.9) !important;
            }

            .card {
                min-width: 50px !important;
                min-height: 70px !important;
                font-size: 12px !important;
            }

            #player-0-hand .card {
                min-width: 60px !important;
                min-height: 85px !important;
            }

            .trump-indicator {
                top: 45% !important;
                right: 10px !important;
            }

            .card-tracker {
                max-width: 200px !important;
                top: 60% !important;
                right: 5px !important;
            }

            #see-last-trick-btn {
                bottom: 10px !important;
                left: 10px !important;
                padding: 8px 12px !important;
                font-size: 11px !important;
            }

            .hint-btn {
                bottom: 10px !important;
                right: 10px !important;
                padding: 8px 12px !important;
                font-size: 11px !important;
            }

            .game-summary-box {
                font-size: 8px !important;
                width: 140px !important;
            }
        }

        .game-container {
            position: relative;
            width: 100dvw;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .game-board {
            position: absolute;
            top: 50%;
            left: 50%;
            width: min(85vw, 85vh);
            height: min(85vw, 85vh);
            transform: translate(-50%, -50%);
            background: 
                radial-gradient(circle at center, rgba(15, 23, 42, 0.9) 0%, rgba(30, 41, 59, 0.8) 100%),
                linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 3px solid var(--border-color);
            box-shadow: 
                0 0 30px rgba(251, 191, 36, 0.2),
                inset 0 0 50px rgba(0, 0, 0, 0.3),
                0 10px 40px rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 768px) {
            .game-board {
                width: 92vw;
                height: 92vw;
                border-width: 2px;
            }
        }
        
        .player-area {
            position: absolute;
            z-index: 50;
            transition: all 0.3s ease;
        }

        .player-bottom { 
            bottom: 0; 
            left: 50%; 
            width: 100vw; 
            height: 22vh;
            transform: translateX(-50%);
        }
        .player-top { 
            top: 0; 
            left: 50%; 
            width: 100vw; 
            height: 22vh;
            transform: translateX(-50%) rotate(180deg);
        }
        .player-left { 
            top: 50%; 
            left: 0; 
            width: 22vh; 
            height: 100vw;
            transform: translateY(-50%) rotate(90deg);
            transform-origin: center;
        }
        .player-right { 
            top: 50%; 
            right: 0; 
            width: 22vh; 
            height: 100vw;
            transform: translateY(-50%) rotate(-90deg);
            transform-origin: center;
        }

        @media (max-width: 768px) {
            .player-bottom { 
                height: 20vh;
                bottom: 0;
            }
            .player-top { 
                height: 20vh;
                top: 0;
            }
            .player-left { 
                width: 20vh;
                left: -5vh;
            }
            .player-right { 
                width: 20vh;
                right: -5vh;
            }
        }
        
        .hand {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 0 10px;
        }
        
        #player-0-hand, #player-2-hand {
            flex-direction: row-reverse;
        }
        
        .hand.bury-selection {
            align-content: center;
            flex-wrap: nowrap;
            gap: 0px;
            justify-content: center;
            overflow-x: visible;
            padding: 0 30px;
        }
        .hand.bury-selection .card {
            margin: 0 25px; 
            transform: scale(1);
            flex-shrink: 0;
        }

        @media (max-width: 768px) {
            .hand {
                padding: 0 5px;
            }
            .hand.bury-selection {
                gap: 0px;
                padding: 0 20px;
            }
            .hand.bury-selection .card {
                margin: 0 18px;
                transform: scale(0.95);
            }
        }

        .card {
            position: relative;
            width: min(12vw, 70px);
            height: min(18vw, 100px);
            background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Teko', sans-serif;
            font-size: clamp(18px, 4vw, 28px);
            font-weight: 600;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: var(--card-shadow);
            margin: 0 -25px;
            transform-style: preserve-3d;
            will-change: transform;
        }

        @media (max-width: 768px) {
            .card {
                width: min(15vw, 60px);
                height: min(22vw, 85px);
                margin: 0 -20px;
                border-radius: 8px;
                font-size: clamp(16px, 3.5vw, 24px);
            }
        }

        @media (max-width: 480px) {
            .card {
                width: min(18vw, 50px);
                height: min(26vw, 72px);
                margin: 0 -15px;
                border-radius: 6px;
                font-size: clamp(14px, 3vw, 20px);
            }
        }
        
        .card .card-face, .card .card-back-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: inherit;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .card .card-back-face {
            background: linear-gradient(145deg, var(--card-back) 0%, #2980b9 100%);
            transform: rotateY(180deg);
            font-size: clamp(24px, 6vw, 40px);
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .card .card-back-face span {
            color: black !important;
        }

        .card.is-flipped .card-face { transform: rotateY(-180deg); }
        .card.is-flipped .card-back-face { transform: rotateY(0deg); }
        
        .player-bottom .card:hover {
            transform: translateY(-15px) scale(1.05);
            z-index: 100;
            box-shadow: var(--card-hover-shadow);
        }

        .card.playable { 
            box-shadow: 0 0 20px 8px rgba(251, 191, 36, 0.6); 
            z-index: 100;
            animation: pulse-glow 2s ease-in-out infinite alternate;
        }
        .card.selected-for-bury { 
            transform: translateY(-15px) scale(1.05); 
            box-shadow: 0 0 20px 8px rgba(52, 152, 219, 0.6); 
            z-index: 101;
        }
        .card.selected-to-play {
            transform: translateY(-20px) scale(1.1) !important;
            box-shadow: 0 0 25px 10px rgba(46, 204, 113, 0.7) !important;
            z-index: 102 !important;
        }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 20px 8px rgba(251, 191, 36, 0.6); }
            100% { box-shadow: 0 0 25px 12px rgba(251, 191, 36, 0.8); }
        }

        @media (max-width: 768px) {
            .player-bottom .card:hover {
                transform: translateY(-10px) scale(1.03);
            }
            .card.selected-for-bury { 
                transform: translateY(-10px) scale(1.03); 
            }
            .card.selected-to-play {
                transform: translateY(-15px) scale(1.05) !important;
            }
        }
        
        .card .rank { 
            position: absolute; 
            top: 6px; 
            left: 8px; 
            font-size: clamp(14px, 3vw, 20px);
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        .card .suit-icon { 
            font-size: clamp(24px, 6vw, 40px);
            filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.1));
        }
        .card[data-suit="Black"] { color: var(--black-suit); }
        .card[data-suit="Red"] { color: var(--red-suit); }
        .card[data-suit="Green"] { color: var(--green-suit); }
        .card[data-suit="Yellow"] { color: var(--yellow-suit); }
        .card[data-suit="Special"] { color: var(--black-suit); }
        .card[data-suit="Special"] .suit-icon { color: black !important; }

        @media (max-width: 768px) {
            .card .rank { 
                top: 4px; 
                left: 6px; 
                font-size: clamp(12px, 2.5vw, 18px);
            }
            .card .suit-icon { 
                font-size: clamp(20px, 5vw, 36px);
            }
        }

        .trick-area, .nest-display-area {
            position: absolute;
            top: 50%; left: 50%;
            width: 65%; height: 65%;
            transform: translate(-50%, -50%);
        }
        .nest-display-area .card { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); cursor: default; }
        .trick-area .card { position: absolute; cursor: default; }
        
        .player-info { 
            position: absolute; 
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            padding: 8px 12px; 
            border-radius: 12px; 
            font-size: clamp(11px, 2.5vw, 14px);
            text-align: center;
            color: var(--text-primary);
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .info-top { 
            top: 23%; 
            left: 50%; 
            transform: translateX(-50%);
        }
        .info-bottom { 
            bottom: 23%; 
            left: 50%; 
            transform: translateX(-50%);
        }
        .info-left { 
            left: 10%; 
            top: 50%; 
            transform: translateY(-50%) rotate(90deg);
            transform-origin: center;
        }
        .info-right { 
            right: 10%; 
            top: 50%; 
            transform: translateY(-50%) rotate(-90deg);
            transform-origin: center;
        }
        .player-info.high-bidder {
            border: 2px solid var(--yellow-suit);
            box-shadow: 0 0 20px 5px rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.1);
        }
        .player-info .dealer-marker {
            color: var(--yellow-suit);
            font-weight: 800;
            text-shadow: 0 0 6px rgba(251, 191, 36, 0.8);
            background: rgba(251, 191, 36, 0.3);
            padding: 1px 2px;
            border-radius: 2px;
            border: 1px solid rgba(251, 191, 36, 0.5);
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .player-info { 
                padding: 6px 10px; 
                font-size: clamp(10px, 2vw, 12px);
                border-radius: 8px;
            }
            .info-top { 
                top: 24%; 
            }
            .info-bottom { 
                bottom: 24%; 
            }
            .info-left { 
                left: 5%; 
            }
            .info-right { 
                right: 5%; 
            }
        }

        .modal { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            display: flex; 
            justify-content: center; 
            z-index: 200; 
            pointer-events: none;
            backdrop-filter: blur(0px);
            transition: backdrop-filter 0.3s ease;
        }
        .modal.active { 
            pointer-events: auto; 
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }
        
        #bury-modal.active {
            background-color: transparent;
            pointer-events: none;
            backdrop-filter: blur(0px);
        }

        /* Bidding modal - show player's hand and nest inside, keep dimming */
        #bidding-modal.active {
            backdrop-filter: blur(3px);
            background-color: rgba(0, 0, 0, 0.6);
            align-items: flex-start;
            padding-top: 3vh;
        }

        #bidding-modal .modal-content {
            max-width: 800px;
            max-height: 95vh;
            overflow-y: auto;
        }

        #bidding-hand-display {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 20px;
            flex-wrap: wrap;
            padding: 15px;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 12px;
            border: 2px solid rgba(251, 191, 36, 0.3);
        }

        #bidding-hand-display .card {
            min-width: 55px;
            min-height: 77px;
            font-size: 11px;
        }

        #bidding-nest-display {
            display: flex;
            justify-content: center;
            gap: -20px;
            margin-top: 15px;
            margin-bottom: 15px;
        }

        #bidding-nest-display .card {
            min-width: 50px;
            min-height: 70px;
            font-size: 10px;
            margin: 0 -15px;
        }

        .bidding-section-label {
            color: var(--yellow-suit);
            font-weight: 700;
            font-size: 14px;
            margin-top: 15px;
            margin-bottom: 8px;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        #bidding-modal, #difficulty-modal, #trump-modal, #round-summary-modal, #last-trick-modal, #settings-modal, #rules-modal, #strategy-modal, #hint-modal, #stats-modal { 
            align-items: center; 
        }
        
        #bury-modal {
            align-items: flex-end;
            padding-bottom: 22%;
        }
        
        .modal-content { 
            background: var(--surface);
            backdrop-filter: blur(20px);
            border: 2px solid var(--glass-border);
            padding: clamp(20px, 5vw, 30px);
            border-radius: 20px; 
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            opacity: 0; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
            transform: scale(0.9) translateY(20px);
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        

        .modal.active .modal-content { 
            opacity: 1; 
            pointer-events: auto;
            transform: scale(1) translateY(0);
        }

        @media (max-width: 768px) {
            .modal-content {
                padding: clamp(15px, 4vw, 25px);
                border-radius: 15px;
                max-width: 95vw;
                max-height: 85vh;
            }
            #bury-modal {
                padding-bottom: 20%;
            }

        }
        
        #bury-modal .modal-content {
            max-width: 400px;
            padding: 15px;
        }
        #bid-input, #winning-score-input { 
            color: var(--text-primary); 
            background: var(--glass-bg);
            border: 2px solid var(--glass-border);
            backdrop-filter: blur(10px);
            text-align: center;
            border-radius: 12px;
            padding: 12px 16px;
            font-size: clamp(14px, 3vw, 16px);
            font-weight: 500;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #bid-input:focus, #winning-score-input:focus {
            outline: none;
            border-color: var(--yellow-suit);
            box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.2);
        }

        .modal-content button, .new-game-btn, .utility-btn { 
            background: linear-gradient(145deg, var(--yellow-suit) 0%, #e6a800 100%);
            color: var(--black-suit); 
            border: none; 
            padding: clamp(10px, 2.5vw, 12px) clamp(16px, 4vw, 20px);
            margin: 6px; 
            border-radius: 12px; 
            font-size: clamp(14px, 3vw, 16px);
            font-weight: 600; 
            cursor: pointer; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
            min-height: 44px; /* Minimum touch target size */
        }
        .modal-content button:hover, .new-game-btn:hover, .utility-btn:hover { 
            background: linear-gradient(145deg, #ffde7a 0%, var(--yellow-suit) 100%);
            transform: translateY(-2px); 
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
        }
        .modal-content button:active, .new-game-btn:active, .utility-btn:active { 
            transform: translateY(0px); 
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        .modal-content button:disabled, .utility-btn:disabled { 
            background: linear-gradient(145deg, #6b7280 0%, #4b5563 100%);
            cursor: not-allowed; 
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transform: none;
        }

        @media (max-width: 768px) {
            .modal-content button, .new-game-btn, .utility-btn { 
                padding: 12px 18px;
                margin: 4px; 
                border-radius: 10px;
                font-size: clamp(13px, 2.5vw, 15px);
                min-height: 48px;
            }
            #bid-input, #winning-score-input { 
                padding: 10px 14px;
                font-size: clamp(13px, 2.5vw, 15px);
                         }
         }

         .trump-suit-btn {
             width: 60px;
             height: 60px;
             border-radius: 50%;
             font-size: 24px;
             font-weight: bold;
             cursor: pointer;
             transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
             box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
             min-height: 44px;
             display: flex;
             align-items: center;
             justify-content: center;
         }
         .trump-suit-btn:hover {
             transform: translateY(-2px) scale(1.05);
             box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
         }
         .trump-suit-btn:active {
             transform: translateY(0px) scale(1);
         }

         @media (max-width: 768px) {
             .trump-suit-btn {
                 width: 55px;
                 height: 55px;
                 font-size: 22px;
             }
         }
         
         .hamburger-menu { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            z-index: 220;
        }
        .hamburger-icon { 
            width: 48px; 
            height: 48px; 
            display: flex; 
            flex-direction: column; 
            justify-content: space-around; 
            cursor: pointer; 
            background: linear-gradient(145deg, var(--yellow-suit) 0%, #e6a800 100%);
            padding: 12px; 
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .hamburger-icon:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
        }
        .hamburger-icon .bar { 
            width: 100%; 
            height: 3px; 
            background-color: var(--black-suit); 
            border-radius: 2px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .dropdown-menu { 
            display: none; 
            position: absolute; 
            right: 0; 
            top: 60px; 
            background: var(--surface);
            backdrop-filter: blur(20px);
            border: 2px solid var(--glass-border); 
            border-radius: 12px; 
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            min-width: 150px;
        }
        .dropdown-menu.show { 
            display: block;
            animation: slideDown 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .dropdown-item { 
            display: block; 
            width: 100%; 
            padding: 12px 20px; 
            color: var(--text-primary); 
            text-align: left; 
            background: none; 
            border: none; 
            cursor: pointer;
            font-size: clamp(13px, 2.5vw, 15px);
            font-weight: 500;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-height: 44px;
            display: flex;
            align-items: center;
        }
        .dropdown-item:hover { 
            background: var(--surface-hover);
            color: var(--yellow-suit);
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .hamburger-menu { 
                top: 15px; 
                right: 15px;
            }
            .hamburger-icon { 
                width: 44px; 
                height: 44px; 
                padding: 10px;
            }
            .dropdown-menu { 
                top: 55px;
                min-width: 140px;
            }
        }

        .trump-indicator { 
            position: fixed; 
            top: 80px; 
            right: 20px; 
            width: 56px; 
            height: 56px; 
            border-radius: 50%; 
            border: 3px solid var(--glass-border); 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            font-size: clamp(20px, 4vw, 28px);
            font-weight: bold; 
            background: var(--surface);
            backdrop-filter: blur(20px);
            z-index: 210;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .status-message { 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            background: var(--surface);
            backdrop-filter: blur(20px);
            padding: clamp(15px, 4vw, 25px) clamp(20px, 6vw, 40px);
            border-radius: 20px; 
            font-size: clamp(16px, 4vw, 24px);
            font-weight: 600; 
            border: 2px solid var(--glass-border); 
            z-index: 250;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            max-width: 90vw;
            text-align: center;
            animation: statusFadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes statusFadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @media (max-width: 768px) {
            .trump-indicator { 
                top: 70px; 
                right: 15px; 
                width: 50px; 
                height: 50px;
                font-size: clamp(18px, 3.5vw, 24px);
            }
            .status-message { 
                padding: clamp(12px, 3vw, 20px) clamp(16px, 4vw, 30px);
                border-radius: 15px; 
                font-size: clamp(14px, 3.5vw, 20px);
                max-width: 85vw;
            }
        }
        
        #widow-on-table {
            position: fixed;
            z-index: 150;
            pointer-events: none;
        }

        /* Compact widow stack styling */
        .widow-stack {
            position: relative;
            width: 40px;
            height: 56px;
        }

        .widow-stack .card {
            position: absolute;
            width: 35px !important;
            height: 50px !important;
            font-size: 8px;
            pointer-events: none;
        }

        .widow-stack .card:nth-child(1) { top: 0px; left: 0px; }
        .widow-stack .card:nth-child(2) { top: 1px; left: 1px; }
        .widow-stack .card:nth-child(3) { top: 2px; left: 2px; }
        .widow-stack .card:nth-child(4) { top: 3px; left: 3px; }
        .widow-stack .card:nth-child(5) { top: 4px; left: 4px; }

        #see-last-trick-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 210;
        }

        .hint-btn {
            position: fixed;
            z-index: 210;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%) !important;
            animation: pulse-hint 2s infinite;
        }

        @keyframes pulse-hint {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(245, 158, 11, 0); }
        }

        .hint-message {
            background: rgba(245, 158, 11, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(251, 191, 36, 0.8);
            border-radius: 12px;
            padding: 15px 20px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 300;
            max-width: 400px;
            color: white;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .hint-message .hint-card {
            font-size: 1.2em;
            font-weight: 700;
            margin: 10px 0;
            color: #fef3c7;
        }

        .hint-message .hint-reason {
            font-size: 0.95em;
            line-height: 1.5;
            margin-top: 10px;
            color: #fef9e7;
        }

        .game-summary-box {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 210;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            padding: 6px;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            font-size: clamp(7px, 1.3vw, 9px);
            width: clamp(140px, 28vw, 170px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            touch-action: none;
            cursor: move;
        }
        /* Position near player who has the Rook */
        .game-summary-box.position-player-0 {
            bottom: 10px;
            top: auto;
            left: 50%;
            transform: translateX(-50%);
        }
        .game-summary-box.position-player-1 {
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
        }
        .game-summary-box.position-player-2 {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
        }
        .game-summary-box.position-player-3 {
            right: 10px;
            left: auto;
            top: 50%;
            transform: translateY(-50%);
        }
        .game-summary-box.collapsed {
            width: auto;
            padding: 3px 6px;
            font-size: clamp(6px, 1.1vw, 8px);
            min-width: auto;
        }
        .game-summary-box.collapsed .game-summary-content {
            display: none;
        }
        .game-summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        .game-summary-header.collapsed-only {
            margin-bottom: 0;
        }
        .collapse-toggle {
            background: rgba(251, 191, 36, 0.2);
            border: 1px solid rgba(251, 191, 36, 0.4);
            color: var(--yellow-suit);
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.2s;
            line-height: 1;
        }
        .game-summary-box.collapsed .collapse-toggle {
            font-size: 10px;
            padding: 1px 4px;
        }
        .collapse-toggle:hover {
            background: rgba(251, 191, 36, 0.3);
            transform: scale(1.05);
        }
        .collapsed-info {
            display: none;
            font-weight: 700;
            color: var(--yellow-suit);
            font-size: 1.1em;
        }
        .game-summary-box.collapsed .collapsed-info {
            display: inline;
        }
        .game-summary-box .total-scores {
            display: flex;
            justify-content: space-between;
            font-weight: 700;
            margin-bottom: 4px;
            color: var(--text-primary);
            background: linear-gradient(145deg, rgba(251, 191, 36, 0.2), rgba(251, 191, 36, 0.1));
            padding: 4px 6px;
            border-radius: 6px;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }
        .game-summary-box .total-scores > div {
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            font-size: 1.1em;
            color: var(--yellow-suit);
        }
        .game-summary-box .dealer-marker {
            color: var(--yellow-suit);
            font-weight: 800;
            text-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
            background: rgba(251, 191, 36, 0.2);
            padding: 1px 3px;
            border-radius: 3px;
            border: 1px solid rgba(251, 191, 36, 0.4);
        }
        .game-summary-box table {
            width: 100%;
            font-size: inherit;
        }
        .game-summary-box td {
            padding: 1px 2px;
            color: var(--text-secondary);
        }
        .game-summary-box td:first-child {
            font-weight: 500;
            color: var(--text-muted);
        }
        
        .last-trick-display { 
            display: flex; 
            justify-content: center; 
            gap: clamp(8px, 2vw, 12px);
            padding: clamp(15px, 4vw, 20px);
            flex-wrap: wrap;
        }

                 @media (max-width: 768px) {
             #see-last-trick-btn {
                 bottom: 15px;
                 left: 15px;
             }
             .game-summary-box {
                 top: 8px;
                 left: 8px;
                 padding: 4px;
                 width: clamp(120px, 25vw, 150px);
                 font-size: clamp(6px, 1.1vw, 8px);
                 border-radius: 6px;
             }
             .collapse-toggle {
                 font-size: 10px;
                 padding: 2px 5px;
             }
             .game-summary-box .total-scores {
                 margin-bottom: 3px;
             }
             .last-trick-display { 
                 gap: clamp(6px, 1.5vw, 10px);
                 padding: clamp(12px, 3vw, 16px);
             }
             #post-bury-actions {
                 bottom: 20%;
                 flex-wrap: wrap;
                 gap: 8px;
                 padding: 16px;
                 max-width: 92vw;
                 border-radius: 16px;
             }
             #post-bury-actions .utility-btn {
                 flex: 1;
                 min-width: 70px;
                 padding: 12px 10px;
                 font-size: 12px;
                 margin: 0;
                 white-space: nowrap;
             }
         }

        /* Card Tracker Styles */
        .card-tracker {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(251, 191, 36, 0.5);
            border-radius: 12px;
            color: white;
            max-width: 280px;
            z-index: 100;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        /* Hide card tracker on hard difficulty */
        .card-tracker.hidden-hard {
            display: none;
        }

        .card-tracker-toggle {
            padding: 10px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            font-size: 14px;
            user-select: none;
        }

        .card-tracker-toggle:hover {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px 10px 0 0;
        }

        .card-tracker-content {
            padding: 0 15px 15px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }

        .card-tracker.expanded .card-tracker-content {
            display: block;
        }

        .card-tracker.collapsed .card-tracker-content {
            display: none;
        }

        .card-tracker.expanded #tracker-arrow {
            transform: rotate(180deg);
        }

        .tracker-suit {
            margin-bottom: 12px;
        }

        .tracker-suit-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .tracker-suit-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            font-size: 11px;
        }

        .tracker-card {
            padding: 3px 6px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .tracker-card.played {
            background: rgba(100, 100, 100, 0.3);
            text-decoration: line-through;
            opacity: 0.5;
        }

        .tracker-card.high-value {
            background: rgba(251, 191, 36, 0.2);
            border-color: rgba(251, 191, 36, 0.5);
            font-weight: 600;
        }

        .tracker-stats {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 12px;
        }

        .tracker-stats > div {
            margin-bottom: 6px;
        }

        @media (max-width: 768px) {
            .card-tracker {
                max-width: 220px;
                font-size: 11px;
            }
            .card-tracker-toggle {
                padding: 8px 12px;
                font-size: 12px;
            }
        }

    </style>
</head>
<body>
    <div class="game-container">
        <div id="game-summary-box" class="game-summary-box hidden"></div>
        <button id="see-last-trick-btn" class="utility-btn" disabled>See Last Trick</button>
        <button id="hint-btn" class="utility-btn hint-btn hidden" style="bottom: 15px; right: 15px;">ðŸ’¡ Hint</button>
        <button id="undo-btn" class="utility-btn hidden" style="bottom: 15px; right: 110px; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);">â†¶ Undo</button>

        <div id="trump-indicator" class="trump-indicator hidden"></div>

        <!-- Card Tracker Panel -->
        <div id="card-tracker" class="card-tracker collapsed">
            <div id="card-tracker-toggle" class="card-tracker-toggle">
                <span>ðŸ“Š Card Tracker</span>
                <span id="tracker-arrow">â–¼</span>
            </div>
            <div id="card-tracker-content" class="card-tracker-content">
                <div id="tracker-suits"></div>
                <div class="tracker-stats">
                    <div><strong>Trump Left:</strong> <span id="tracker-trump-count">-</span></div>
                    <div><strong>Points Left:</strong> <span id="tracker-points-left">180</span></div>
                </div>
            </div>
        </div>
        
        <div id="hamburger-menu" class="hamburger-menu">
            <div id="hamburger-icon" class="hamburger-icon">
                <div class="bar"></div>
                <div class="bar"></div>
                <div class="bar"></div>
            </div>
            <div id="dropdown-menu" class="dropdown-menu">
                <button id="menu-new-game" class="dropdown-item">New Game</button>
                <button id="menu-settings" class="dropdown-item">Settings</button>
                <button id="menu-stats" class="dropdown-item">Statistics</button>
                <button id="menu-exit" class="dropdown-item">Exit</button>
            </div>
        </div>
        
        <div class="player-area player-top"><div id="player-2-hand" class="hand"></div></div>
        <div class="player-area player-left"><div id="player-1-hand" class="hand"></div></div>
        <div class="player-area player-right"><div id="player-3-hand" class="hand"></div></div>
        <div class="player-area player-bottom"><div id="player-0-hand" class="hand"></div></div>

        <div id="player-0-info" class="player-info info-bottom"></div>
        <div id="player-1-info" class="player-info info-left"></div>
        <div id="player-2-info" class="player-info info-top"></div>
        <div id="player-3-info" class="player-info info-right"></div>

        <div class="game-board">
            <div id="nest-display-area" class="nest-display-area"></div>
            <div id="trick-area" class="trick-area"></div>
            <div id="widow-on-table"></div>
        </div>

        <div id="status-message" class="status-message hidden"></div>

        <!-- Action buttons for after burying widow -->
        <div id="post-bury-actions" class="hidden fixed bottom-[22%] left-1/2 -translate-x-1/2 z-[150] flex gap-3 p-4 bg-black/30 backdrop-blur-lg rounded-2xl border-2 border-white/20 shadow-lg">
            <button id="action-call-trump" class="utility-btn">Call Trump</button>
            <button id="action-ask-partner" class="utility-btn bg-blue-500 hover:bg-blue-600">Ask Partner</button>
            <button id="action-no-trump" class="utility-btn bg-gray-500 hover:bg-gray-600">No Trump</button>
            <button id="action-fold" class="utility-btn bg-red-600 hover:bg-red-700">Fold</button>
        </div>

        <!-- Modals -->
        <div id="difficulty-modal" class="modal active"></div>
        <div id="bidding-modal" class="modal"></div>
        <div id="trump-modal" class="modal"></div>
        <div id="bury-modal" class="modal"></div>
        <div id="round-summary-modal" class="modal"></div>
        <div id="last-trick-modal" class="modal"></div>
        <div id="settings-modal" class="modal"></div>
        <div id="rules-modal" class="modal"></div>
        <div id="strategy-modal" class="modal"></div>
        <div id="hint-modal" class="modal"></div>
        <div id="stats-modal" class="modal"></div>
    </div>

    <script>
        const SUITS = ['Black', 'Red', 'Green', 'Yellow'];
        const RANKS = [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 1];
        let WINNING_SCORE = 500;
        const HUMAN_PLAYER_ID = 0;

        class Card {
            constructor(suit, rank) { this.suit = suit; this.rank = rank; this.id = `${suit}-${rank}`; }
            get value() { if (this.rank === 'Rook') return 20; const r = Number(this.rank); if (r === 1) return 15; if (r === 10 || r === 14) return 10; if (r === 5) return 5; return 0; }
            get power() { if (this.rank === 'Rook') return 20; const r = Number(this.rank); if (r === 1) return 15; return r; }
        }

        class Deck {
            constructor() { this.cards = []; this.create(); }
            create() { this.cards = []; for (const suit of SUITS) { for (const rank of RANKS) { this.cards.push(new Card(suit, rank)); } } this.cards.push(new Card('Special', 'Rook')); }
            shuffle() { for (let i = this.cards.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]]; } }
            deal(numPlayers, cardsPerPlayer) {
                const hands = Array.from({ length: numPlayers }, () => []);
                const nest = [];
                for (let i = 0; i < 5; i++) { nest.push(this.cards.pop()); }
                for (let i = 0; i < cardsPerPlayer; i++) { for (let j = 0; j < numPlayers; j++) { hands[j].push(this.cards.pop()); } }
                return { hands, nest };
            }
        }

        class Player {
            constructor(id, isHuman = false) { this.id = id; this.hand = []; this.isHuman = isHuman; this.partnerId = (id + 2) % 4; this.hasPassed = false; }
            sortHand(trumpSuit = null, sortOrder = 'asc') {
                this.hand.sort((a, b) => {
                    const isARook = a.rank === 'Rook';
                    const isBRook = b.rank === 'Rook';

                    if (isARook) return sortOrder === 'asc' ? 1 : -1;
                    if (isBRook) return sortOrder === 'asc' ? -1 : 1;
                    
                    if (trumpSuit !== null) {
                        const isATrump = a.suit === trumpSuit;
                        const isBTrump = b.suit === trumpSuit;
                        if (isATrump !== isBTrump) {
                            return (sortOrder === 'asc' ? 1 : -1) * (isATrump ? 1 : -1);
                        }
                    }
                    
                    if (a.suit !== b.suit) {
                        return SUITS.indexOf(a.suit) - SUITS.indexOf(b.suit);
                    }

                    return (sortOrder === 'asc' ? 1 : -1) * (a.power - b.power);
                });
            }

            getBid(currentBid, hasShootTheMoonOption, difficulty, highBidder, previousBid) {
                // Partner awareness: Check if partner made a large bid increase
                const isPartnerHighBidder = highBidder && highBidder.id === this.partnerId;
                const partnerBidIncrease = previousBid ? (currentBid - previousBid) : 0;
                const partnerMadeLargeIncrease = isPartnerHighBidder && partnerBidIncrease > 15;

                // Simple AI for bidding
                const pointCards = this.hand.filter(c => c.value > 5).length;
                const rook = this.hand.some(c => c.rank === 'Rook');
                const ones = this.hand.filter(c => c.rank === 1).length;
                let bidStrength = pointCards * 10 + (rook ? 20 : 0);

                const potentialBid = 85 + Math.floor(bidStrength / 5) * 5;

                // Don't overbid partner unless we have a very strong hand
                if (partnerMadeLargeIncrease) {
                    // Need Rook + 2+ Aces or 3+ Aces to overbid partner
                    const veryStrongHand = (rook && ones >= 2) || (ones >= 3);
                    if (!veryStrongHand) {
                        return 'pass';
                    }
                }

                if (potentialBid > currentBid) {
                    return potentialBid;
                }

                // Competitive bidding: Push opponents' bids higher
                // Don't do this if partner is high bidder
                if (!isPartnerHighBidder && highBidder && currentBid < 130) {
                    // Consider competitive bidding if the bid is still relatively low
                    const minStrengthForCompetitive = currentBid < 105 ? 30 : 40;

                    if (bidStrength >= minStrengthForCompetitive) {
                        // Push the bid up slightly to make opponent pay more
                        const pushAmount = currentBid < 105 ? 10 : 5;
                        const competitiveBid = currentBid + pushAmount;

                        // Don't push too far beyond our potential bid
                        if (competitiveBid <= potentialBid + 10) {
                            return competitiveBid;
                        }
                    }
                }

                return 'pass';
            }

            chooseCardsToBury(difficulty) {
                // Simple AI for burying cards
                this.sortHand(game.trumpSuit, 'asc'); // Sort to put low cards first
                const nonTrumps = this.hand.filter(c => c.suit !== game.trumpSuit && c.rank !== 'Rook');
                return nonTrumps.slice(0, 5); // Bury the 5 lowest non-trumps
            }

            playCard(trick, trumpSuit, difficulty) {
                const playableCards = this.getPlayableCards(trick.map(p => p.card), trumpSuit);
                // Simple AI: play the first playable card
                return playableCards.sort((a, b) => a.power - b.power)[0];
            }
            
            chooseTrump() {
                let bestSuit = '';
                let maxSuitScore = -1;
                for (const suit of SUITS) {
                    let currentSuitScore = 0;
                    const suitCards = this.hand.filter(c => c.suit === suit);
                    const highCards = suitCards.filter(c => c.power >= 13);
                    currentSuitScore += suitCards.length * 2;
                    currentSuitScore += highCards.length * 5;
                    if (this.hand.some(c => c.rank === 'Rook')) currentSuitScore += 3;

                    if (currentSuitScore > maxSuitScore) {
                        maxSuitScore = currentSuitScore;
                        bestSuit = suit;
                    }
                }
                return bestSuit || SUITS[Math.floor(Math.random() * SUITS.length)]; // Fallback
            }

            getAdvancedBid(currentBid, hasShootTheMoonOption, highBidder, previousBid) {
                // Partner awareness: Check if partner made a large bid increase
                const isPartnerHighBidder = highBidder && highBidder.id === this.partnerId;
                const partnerBidIncrease = previousBid ? (currentBid - previousBid) : 0;
                const partnerMadeLargeIncrease = isPartnerHighBidder && partnerBidIncrease > 15;

                let handValue = 0;

                // Point card values with adjusted valuations
                const hasRook = this.hand.filter(c => c.rank === 'Rook').length > 0;
                handValue += hasRook ? 20 : 0;
                const ones = this.hand.filter(c => c.rank === 1);
                handValue += ones.length * 15;
                const fourteens = this.hand.filter(c => c.rank === 14);
                handValue += fourteens.length * 10;
                const tens = this.hand.filter(c => c.rank === 10);
                handValue += tens.length * 8;
                const fives = this.hand.filter(c => c.rank === 5);
                handValue += fives.length * 5;

                const suitCounts = SUITS.reduce((acc, suit) => {
                    acc[suit] = this.hand.filter(c => c.suit === suit).length;
                    return acc;
                }, {});

                // Find best potential trump suit
                let bestTrumpLength = 0;
                let bestTrumpSuit = '';
                for (const suit in suitCounts) {
                    if (suitCounts[suit] > bestTrumpLength) {
                        bestTrumpLength = suitCounts[suit];
                        bestTrumpSuit = suit;
                    }
                }

                // Suit quality bonus (for potential trump)
                if (bestTrumpLength >= 6) {
                    const trumpCards = this.hand.filter(c => c.suit === bestTrumpSuit);
                    const highTrumps = trumpCards.filter(c => c.power >= 13).length; // 1, 14, 13
                    handValue += bestTrumpLength * 6; // Reduced from 8
                    handValue += highTrumps * 8; // Reduced from 10

                    // Extra bonus for very long trump
                    if (bestTrumpLength >= 7) handValue += 15; // Reduced from 20
                } else if (bestTrumpLength >= 5) {
                    handValue += bestTrumpLength * 4; // Reduced from 5
                }

                // Distribution bonuses
                let voidCount = 0;
                let singletonCount = 0;
                for (const suit in suitCounts) {
                    if (suit === bestTrumpSuit) continue; // Don't count trump suit
                    if (suitCounts[suit] === 0) {
                        handValue += 10; // Reduced from 15
                        voidCount++;
                    } else if (suitCounts[suit] === 1) {
                        handValue += 5;  // Reduced from 8
                        singletonCount++;
                    }
                }

                // Nest expectation: more conservative, only add if hand is promising
                const nestExpectation = handValue > 60 ? 8 : 5;
                handValue += nestExpectation;

                // Check for "shoot the moon" hand - stricter requirements
                const quickTricks = (hasRook ? 1 : 0) + ones.length;
                const controlSuits = Object.values(suitCounts).filter(count => count >= 5).length;
                if (handValue > 150 && quickTricks >= 4 && controlSuits >= 2 && bestTrumpLength >= 7 && hasShootTheMoonOption) {
                    return 'shoot';
                }

                // Convert hand value to a conservative bid
                // More realistic conversion: need ~2 handValue points per bid point above 90
                let potentialBid = 90 + Math.floor(Math.max(0, handValue - 50) / 2.5) * 5;
                potentialBid = Math.min(potentialBid, 180);

                // Strict requirements for high bids
                if (potentialBid >= 170) {
                    // Must have exceptional hand: Rook + 3+ 1s OR Rook + 2 1s + 8+ trump
                    const exceptionalHand = (hasRook && ones.length >= 3) ||
                                          (hasRook && ones.length >= 2 && bestTrumpLength >= 8) ||
                                          (ones.length >= 4 && bestTrumpLength >= 7);
                    if (!exceptionalHand) {
                        potentialBid = Math.min(potentialBid, 165);
                    }
                } else if (potentialBid >= 160) {
                    // Must have very strong hand: Rook + 2+ 1s OR 3+ 1s + 7+ trump
                    const veryStrongHand = (hasRook && ones.length >= 2) ||
                                         (ones.length >= 3 && bestTrumpLength >= 7);
                    if (!veryStrongHand) {
                        potentialBid = Math.min(potentialBid, 155);
                    }
                } else if (potentialBid >= 150) {
                    // Must have strong hand: Rook OR 2+ 1s + good trump
                    const strongHand = hasRook || (ones.length >= 2 && bestTrumpLength >= 6);
                    if (!strongHand) {
                        potentialBid = Math.min(potentialBid, 145);
                    }
                }

                // Partner awareness: Don't overbid partner unless we have a near-180 hand
                if (partnerMadeLargeIncrease) {
                    // Partner signaled a very strong hand - only overbid if we can likely make 180
                    const exceptionalHand180 = (hasRook && ones.length >= 3) ||
                                               (hasRook && ones.length >= 2 && bestTrumpLength >= 8) ||
                                               (ones.length >= 4 && bestTrumpLength >= 7);

                    if (!exceptionalHand180) {
                        // Partner has a strong hand, let them have it
                        return 'pass';
                    }
                    // Only bid if we can reasonably go to 180
                    if (potentialBid < 175) {
                        return 'pass';
                    }
                }

                // Bidding strategy
                if (potentialBid > currentBid && potentialBid >= 90) {
                    // Conservative bidding: smaller jumps
                    const jumpSize = Math.min(15, potentialBid - currentBid);
                    return currentBid + jumpSize;
                }

                // Competitive bidding: Push opponents' bids higher
                // Don't do this if partner is high bidder
                if (!isPartnerHighBidder && highBidder && currentBid < 140) {
                    // Consider competitive bidding if the bid is still relatively low
                    const minHandForCompetitive = currentBid < 110 ? 40 : 55;

                    if (handValue >= minHandForCompetitive) {
                        // Push the bid up slightly to make opponent pay more
                        // More aggressive pushes when bid is lower
                        const pushAmount = currentBid < 110 ? 10 : 5;
                        const competitiveBid = currentBid + pushAmount;

                        // Don't push beyond what we think we could reasonably make
                        if (competitiveBid <= potentialBid + 15) {
                            return competitiveBid;
                        }
                    }
                }

                return 'pass';
            }

            chooseAdvancedTrumpAndBury() {
                let bestSuit = '';
                let maxSuitScore = -1;

                // 1. Determine the best trump suit from the 15 cards
                for (const suit of SUITS) {
                    let currentSuitScore = 0;
                    const trumps = this.hand.filter(c => c.suit === suit);
                    const controlCards = trumps.filter(c => c.power >= 13); // 13, 14, 1
                    
                    currentSuitScore += trumps.length * 10; // Base value for length
                    currentSuitScore += controlCards.length * 15; // Value for high trumps
                    if (this.hand.some(c => c.rank === 'Rook')) {
                        currentSuitScore += 20; // Rook is always good
                    }

                    if (currentSuitScore > maxSuitScore) {
                        maxSuitScore = currentSuitScore;
                        bestSuit = suit;
                    }
                }
                game.trumpSuit = bestSuit; // Temporarily set for sorting

                // 2. Identify cards to bury
                const cardsToKeep = [];
                const cardsToConsiderBurying = [];

                // Always keep the Rook and all trumps
                this.hand.forEach(card => {
                    if (card.rank === 'Rook' || card.suit === bestSuit) {
                        cardsToKeep.push(card);
                    } else {
                        cardsToConsiderBurying.push(card);
                    }
                });

                // Keep off-suit Aces (1s)
                const offSuitAces = cardsToConsiderBurying.filter(c => c.rank === 1);
                cardsToKeep.push(...offSuitAces);
                
                // The rest are candidates for burying
                let buryCandidates = cardsToConsiderBurying.filter(c => c.rank !== 1);

                // Prioritize burying to create voids/singletons
                buryCandidates.sort((a, b) => {
                    const suitCountA = this.hand.filter(c => c.suit === a.suit).length;
                    const suitCountB = this.hand.filter(c => c.suit === b.suit).length;
                    if (suitCountA !== suitCountB) {
                        return suitCountA - suitCountB; // Bury from shorter suits first
                    }
                    return a.value - b.value; // Then bury lower value cards
                });

                const toBury = buryCandidates.slice(0, 5);
                
                // Final hand is what's left
                this.hand = this.hand.filter(c => !toBury.includes(c));

                return { trumpSuit: bestSuit, buriedCards: toBury };
            }

            // Card counting helpers
            getPlayedCards(trickHistory) {
                return trickHistory.flat().map(p => p.card);
            }

            getRemainingCardsBysuit(trickHistory, trumpSuit) {
                const playedCards = this.getPlayedCards(trickHistory);
                const remaining = {};

                SUITS.forEach(suit => {
                    remaining[suit] = RANKS.filter(rank => {
                        return !playedCards.some(c => c.suit === suit && c.rank === rank);
                    });
                });

                // Track Rook separately
                remaining.Rook = !playedCards.some(c => c.rank === 'Rook');

                return remaining;
            }

            getTrumpCount(trickHistory, trumpSuit) {
                if (!trumpSuit) return 0;
                const playedCards = this.getPlayedCards(trickHistory);
                const playedTrumps = playedCards.filter(c => c.suit === trumpSuit || c.rank === 'Rook').length;
                const totalTrumps = 11 + 1; // 11 cards per suit + Rook
                return totalTrumps - playedTrumps;
            }

            detectPartnerVoids(trickHistory) {
                const voids = new Set();

                trickHistory.forEach(trick => {
                    if (trick.length < 2) return;

                    const leadCard = trick[0].card;
                    const leadSuit = leadCard.rank === 'Rook' ? null : leadCard.suit;

                    trick.forEach(play => {
                        if (play.player.id === this.partnerId && leadSuit) {
                            // If partner didn't follow suit, they're void
                            if (play.card.suit !== leadSuit && play.card.rank !== 'Rook') {
                                voids.add(leadSuit);
                            }
                        }
                    });
                });

                return voids;
            }

            playAdvancedCard(trick, trumpSuit, trickHistory, gameState = null) {
                const playableCards = this.getPlayableCards(trick.map(p => p.card), trumpSuit);
                const trickCards = trick.map(p => p.card);
                const remainingCards = this.getRemainingCardsBysuit(trickHistory, trumpSuit);
                const trumpsRemaining = this.getTrumpCount(trickHistory, trumpSuit);
                const partnerVoids = this.detectPartnerVoids(trickHistory);
                const tricksPlayed = trickHistory.length;
                const tricksRemaining = 10 - tricksPlayed;

                // Calculate current trick value
                const currentTrickValue = trickCards.reduce((sum, c) => sum + c.value, 0);

                // Endgame awareness - understand the score situation
                let needsAggression = false;
                let preventOpponentPoints = false;
                if (gameState) {
                    const myTeamId = this.id % 2; // 0,2 = team1, 1,3 = team2
                    const myTeamTricks = myTeamId === 0 ? gameState.team1Tricks : gameState.team2Tricks;
                    const opponentTricks = myTeamId === 0 ? gameState.team2Tricks : gameState.team1Tricks;
                    const myTeamPoints = myTeamTricks.reduce((sum, c) => sum + c.value, 0);
                    const opponentPoints = opponentTricks.reduce((sum, c) => sum + c.value, 0);

                    const biddingTeam = gameState.highBidderId % 2;
                    const isBiddingTeam = myTeamId === biddingTeam;

                    if (isBiddingTeam) {
                        // We made the bid - check if we're close to making it
                        const pointsNeeded = gameState.highBid - myTeamPoints - gameState.widowValue;
                        if (pointsNeeded > 0 && pointsNeeded <= 40) {
                            needsAggression = true; // Need to take tricks with points
                        }
                    } else {
                        // Opponent made the bid - try to set them
                        const opponentPointsWithWidow = opponentPoints + gameState.widowValue;
                        const opponentShortfall = gameState.highBid - opponentPointsWithWidow;
                        if (opponentShortfall > -20 && opponentShortfall < 40) {
                            preventOpponentPoints = true; // Close game - prevent them from making bid
                        }
                    }
                }

                // If leading the trick
                if (trick.length === 0) {
                    const trumpsInHand = this.hand.filter(c => c.suit === trumpSuit || c.rank === 'Rook');
                    const trumpsInOpponentHands = trumpsRemaining - trumpsInHand.length;

                    // Strategy: Pull trump if we have strong trump and opponents likely have trump
                    if (trumpsInHand.length >= 5 && trumpsInOpponentHands > 0 &&
                        trumpsInHand.some(c => c.power > 13)) {
                        // Lead trump to pull opponent's trump, but save Rook unless late game
                        const trumpToLead = trumpsInHand
                            .filter(c => c.rank !== 'Rook' || tricksRemaining <= 3)
                            .sort((a,b) => b.power - a.power)[0];
                        if (trumpToLead) return trumpToLead;
                    }

                    // Avoid leading suits where partner is void (wastes a trick)
                    const safeLeads = SUITS.filter(s => !partnerVoids.has(s) && s !== trumpSuit);

                    // Lead singletons in non-trump suits (creates voids for rufing)
                    const suitCounts = SUITS.reduce((acc, s) => ({...acc, [s]: this.hand.filter(c => c.suit === s).length}), {});
                    const singletonSuit = safeLeads.find(s => suitCounts[s] === 1);
                    if (singletonSuit) {
                        return this.hand.find(c => c.suit === singletonSuit);
                    }

                    // Lead from short suits where we can potentially ruff later
                    const shortSuits = safeLeads
                        .filter(s => suitCounts[s] > 0 && suitCounts[s] <= 2)
                        .sort((a, b) => suitCounts[a] - suitCounts[b]);

                    if (shortSuits.length > 0) {
                        const cardsInShortSuit = this.hand.filter(c => c.suit === shortSuits[0]);
                        return cardsInShortSuit.sort((a,b) => a.power - b.power)[0]; // Lead low
                    }

                    // Default: lead lowest non-trump
                    const nonTrumps = playableCards.filter(c => c.suit !== trumpSuit && c.rank !== 'Rook');
                    return (nonTrumps.length > 0 ? nonTrumps : playableCards).sort((a,b) => a.power - b.power)[0];
                }

                // If following suit
                const winnerInfo = game.determineTrickWinner(trick);
                const partnerIsWinning = winnerInfo && winnerInfo.player.id === this.partnerId;

                if (partnerIsWinning) {
                    // "Smear" points if partner is winning
                    const pointCards = playableCards.filter(c => c.value > 0).sort((a, b) => b.value - a.value);
                    if (pointCards.length > 0) {
                        // Don't waste Rook on low-value tricks early in the hand
                        if (currentTrickValue < 15 && tricksRemaining > 4) {
                            const nonRookPoints = pointCards.filter(c => c.rank !== 'Rook');
                            if (nonRookPoints.length > 0) return nonRookPoints[0];
                        }
                        return pointCards[0]; // Play highest point card
                    }
                    // Otherwise, slough off lowest card (save trump)
                    const nonTrumps = playableCards.filter(c => c.suit !== trumpSuit && c.rank !== 'Rook');
                    return (nonTrumps.length > 0 ? nonTrumps : playableCards).sort((a, b) => a.power - b.power)[0];
                } else {
                    // Try to win the trick
                    const leadSuit = trickCards[0].rank === 'Rook' ? trumpSuit : trickCards[0].suit;
                    const winningCard = winnerInfo.card;
                    const trickValue = currentTrickValue + playableCards.reduce((sum, c) => sum + c.value, 0);

                    const canWinCards = playableCards.filter(c => {
                        if (c.rank === 'Rook') return true;
                        if (winningCard.rank === 'Rook') return false;
                        if (trumpSuit !== null && c.suit === trumpSuit && winningCard.suit !== trumpSuit) return true;
                        if (trumpSuit !== null && c.suit === trumpSuit && winningCard.suit === trumpSuit) return c.power > winningCard.power;
                        if (c.suit === leadSuit && (trumpSuit === null || winningCard.suit !== trumpSuit)) return c.power > winningCard.power;
                        return false;
                    });

                    if (canWinCards.length > 0) {
                        // Decide if we should try to win based on trick value and game situation
                        let worthWinning = trickValue >= 15 || tricksRemaining <= 3;

                        // Endgame adjustments
                        if (needsAggression && trickValue >= 10) {
                            worthWinning = true; // Be more aggressive when we need points
                        }
                        if (preventOpponentPoints && trickValue >= 10) {
                            worthWinning = true; // Prevent opponents from scoring
                        }

                        // Don't waste Rook on low-value tricks early unless in critical situation
                        if (!worthWinning && tricksRemaining > 4 && !needsAggression) {
                            const nonRookWinners = canWinCards.filter(c => c.rank !== 'Rook');
                            if (nonRookWinners.length > 0) {
                                return nonRookWinners.sort((a, b) => a.power - b.power)[0];
                            }
                            // If only Rook can win and trick isn't valuable, don't win
                            return playableCards.filter(c => c.rank !== 'Rook').sort((a, b) => a.power - b.power)[0] || playableCards[0];
                        }

                        // Win with the lowest possible card
                        return canWinCards.sort((a, b) => a.power - b.power)[0];
                    }

                    // Can't win - try to smear points if valuable trick or opponent winning points
                    if (trickValue >= 15 || (preventOpponentPoints && trickValue >= 10)) {
                        const pointCards = playableCards.filter(c => c.value > 0 && c.rank !== 'Rook');
                        if (pointCards.length > 0) {
                            return pointCards.sort((a, b) => b.value - a.value)[0];
                        }
                    }

                    // Can't win, play lowest card
                    return playableCards.sort((a, b) => a.power - b.power)[0];
                }
            }

            getPlayableCards(trickCards, trumpSuit) {
                if (!trickCards || trickCards.length === 0) {
                    return [...this.hand];
                }

                const leadCard = trickCards[0];
                
                if (trumpSuit === null) { // No Trump logic
                    // Rook is special, but not a suit. If led, anyone can play anything.
                    if (leadCard.rank === 'Rook') {
                        return [...this.hand];
                    }
                    // Must follow suit if possible
                    const cardsInLeadSuit = this.hand.filter(c => c.suit === leadCard.suit);
                    if (cardsInLeadSuit.length > 0) {
                        return cardsInLeadSuit;
                    }
                    return [...this.hand]; // Can play anything if void in lead suit
                }

                // Standard trump logic
                const leadSuit = leadCard.rank === 'Rook' ? trumpSuit : leadCard.suit;

                const cardsInLeadSuit = this.hand.filter(c => {
                    if (leadSuit === trumpSuit) {
                        // If trump is led, must play trump (or Rook)
                        return c.suit === trumpSuit || c.rank === 'Rook';
                    }
                    // If non-trump is led, must follow suit
                    return c.suit === leadSuit;
                });

                if (cardsInLeadSuit.length > 0) {
                    return cardsInLeadSuit;
                }
                return [...this.hand]; // If void in lead suit, can play anything
            }
        }

        class Game {
            constructor() {
                this.dom = {
                    hands: Array.from({length: 4}, (_, i) => document.getElementById(`player-${i}-hand`)),
                    infos: Array.from({length: 4}, (_, i) => document.getElementById(`player-${i}-info`)),
                    trickArea: document.getElementById('trick-area'),
                    nestDisplay: document.getElementById('nest-display-area'),
                    widowOnTable: document.getElementById('widow-on-table'),
                    gameSummaryBox: document.getElementById('game-summary-box'),
                    difficultyModal: document.getElementById('difficulty-modal'),
                    biddingModal: document.getElementById('bidding-modal'),
                    buryModal: document.getElementById('bury-modal'),
                    trumpModal: document.getElementById('trump-modal'),
                    lastTrickModal: document.getElementById('last-trick-modal'),
                    settingsModal: document.getElementById('settings-modal'),
                    rulesModal: document.getElementById('rules-modal'),
                    strategyModal: document.getElementById('strategy-modal'),
                    statusMessage: document.getElementById('status-message'),
                    seeLastTrickBtn: document.getElementById('see-last-trick-btn'),
                    trumpIndicator: document.getElementById('trump-indicator'),
                    roundSummaryModal: document.getElementById('round-summary-modal'),
                    postBuryActions: document.getElementById('post-bury-actions'),
                    hamburgerIcon: document.getElementById('hamburger-icon'),
                    dropdownMenu: document.getElementById('dropdown-menu'),
                    menuNewGame: document.getElementById('menu-new-game'),
                    menuSettings: document.getElementById('menu-settings'),
                    menuStats: document.getElementById('menu-stats'),
                    menuExit: document.getElementById('menu-exit'),
                    cardTracker: document.getElementById('card-tracker'),
                    cardTrackerToggle: document.getElementById('card-tracker-toggle'),
                    trackerSuits: document.getElementById('tracker-suits'),
                    trackerTrumpCount: document.getElementById('tracker-trump-count'),
                    trackerPointsLeft: document.getElementById('tracker-points-left'),
                    hintBtn: document.getElementById('hint-btn'),
                    hintModal: document.getElementById('hint-modal'),
                    statsModal: document.getElementById('stats-modal'),
                    undoBtn: document.getElementById('undo-btn'),
                };
                this.players = [new Player(0, true), new Player(1), new Player(2), new Player(3)];
                this.scores = { team1: 0, team2: 0 };
                this.dealerIndex = 3;
                this.handHistory = [];
                this.lastTrick = [];
                this.trickHistory = [];
                this.handSortOrder = 'asc';
                this.stats = this.loadStats();
                this.initModals();
                this.initMenu();
                this.initCardTracker();
                this.initHints();
                this.initUndo();
                this.initSummaryDrag();
                this.dom.seeLastTrickBtn.addEventListener('click', () => this.showLastTrick());
            }

            initMenu() {
                this.dom.hamburgerIcon.addEventListener('click', () => {
                    this.dom.dropdownMenu.classList.toggle('show');
                });
                this.dom.menuNewGame.addEventListener('click', () => {
                    this.dom.dropdownMenu.classList.remove('show');
                    this.showModal('difficulty');
                });
                this.dom.menuSettings.addEventListener('click', () => {
                    this.dom.dropdownMenu.classList.remove('show');
                    this.showModal('settings');
                });
                this.dom.menuStats.addEventListener('click', () => {
                    this.dom.dropdownMenu.classList.remove('show');
                    this.showStats();
                });
                this.dom.menuExit.addEventListener('click', () => {
                    this.dom.dropdownMenu.classList.remove('show');
                    this.showModal('difficulty');
                });
                document.addEventListener('click', (e) => {
                    if (!this.dom.hamburgerIcon.contains(e.target) && !this.dom.dropdownMenu.contains(e.target)) {
                        this.dom.dropdownMenu.classList.remove('show');
                    }
                });
            }

            initCardTracker() {
                this.dom.cardTrackerToggle.addEventListener('click', () => {
                    this.dom.cardTracker.classList.toggle('collapsed');
                    this.dom.cardTracker.classList.toggle('expanded');
                });
            }

            updateCardTracker() {
                if (!this.trickHistory || this.trickHistory.length === 0) {
                    // Initialize tracker at start of hand
                    let html = '';
                    SUITS.forEach(suit => {
                        html += `<div class="tracker-suit">
                            <div class="tracker-suit-name">
                                <span style="color: var(--${suit.toLowerCase()}-suit)">â—</span> ${suit}
                            </div>
                            <div class="tracker-suit-cards" data-suit="${suit}">`;
                        RANKS.forEach(rank => {
                            const isHighValue = rank === 1 || rank === 14 || rank === 10 || rank === 5;
                            const displayRank = rank === 1 ? 'A' : rank;
                            html += `<span class="tracker-card ${isHighValue ? 'high-value' : ''}" data-suit="${suit}" data-rank="${rank}">${displayRank}</span>`;
                        });
                        html += `</div></div>`;
                    });
                    html += `<div class="tracker-suit">
                        <div class="tracker-suit-name">ðŸŽ­ Rook</div>
                        <div class="tracker-suit-cards">
                            <span class="tracker-card high-value" data-rank="Rook">Rook</span>
                        </div>
                    </div>`;
                    this.dom.trackerSuits.innerHTML = html;
                    this.dom.trackerTrumpCount.textContent = '-';
                    this.dom.trackerPointsLeft.textContent = '180';
                    return;
                }

                // Mark played cards
                const playedCards = this.trickHistory.flat().map(p => p.card);
                playedCards.forEach(card => {
                    const selector = card.rank === 'Rook'
                        ? `.tracker-card[data-rank="Rook"]`
                        : `.tracker-card[data-suit="${card.suit}"][data-rank="${card.rank}"]`;
                    const cardEl = this.dom.trackerSuits.querySelector(selector);
                    if (cardEl) {
                        cardEl.classList.add('played');
                    }
                });

                // Update trump count
                if (this.trumpSuit) {
                    const playedTrumps = playedCards.filter(c =>
                        c.suit === this.trumpSuit || c.rank === 'Rook'
                    ).length;
                    const trumpsLeft = 12 - playedTrumps; // 11 suit cards + Rook
                    this.dom.trackerTrumpCount.textContent = trumpsLeft;
                }

                // Update points left
                const pointsPlayed = playedCards.reduce((sum, c) => sum + c.value, 0);
                const pointsLeft = 180 - pointsPlayed;
                this.dom.trackerPointsLeft.textContent = pointsLeft;
            }

            initHints() {
                this.dom.hintBtn.addEventListener('click', () => this.showHint());
            }

            initUndo() {
                this.dom.undoBtn.addEventListener('click', () => {
                    if (this.difficulty !== 'practice' || !this.undoState) return;

                    // Restore saved state
                    const human = this.players[0];
                    human.hand = [...this.undoState.hand];
                    this.currentTrick = [...this.undoState.currentTrick];

                    // Re-render
                    this.renderPlayerHand(0);
                    this.renderTrick();

                    // Hide undo button
                    this.dom.undoBtn.classList.add('hidden');

                    // Show message
                    this.showMessage('Move undone! Choose a different card.', 2000);

                    // Clear undo state so it can't be used again
                    this.undoState = null;

                    // Allow human to play again
                    this.resumeAfterUndo = true;
                });
            }

            showHint() {
                if (!this.currentTrick || this.difficulty === 'hard') return;

                const humanPlayer = this.players[0];
                const gameState = {
                    scores: this.scores,
                    highBid: this.highBid,
                    highBidderId: this.highBidder.id,
                    team1Tricks: this.team1Tricks,
                    team2Tricks: this.team2Tricks,
                    widowValue: this.widow.reduce((sum, c) => sum + c.value, 0)
                };

                // Use AI logic to get best card
                const suggestedCard = humanPlayer.playAdvancedCard(
                    this.currentTrick,
                    this.trumpSuit,
                    this.trickHistory,
                    gameState
                );

                const reason = this.explainCardChoice(suggestedCard, humanPlayer, this.currentTrick, this.trumpSuit);

                // Display hint modal
                const cardDisplay = suggestedCard.rank === 'Rook' ? 'Rook' :
                    `${suggestedCard.suit} ${suggestedCard.rank === 1 ? 'Ace' : suggestedCard.rank}`;

                this.dom.hintModal.innerHTML = this.createModalContent('ðŸ’¡ Hint', `
                    <div class="hint-message">
                        <div class="hint-card">Suggested Play: ${cardDisplay}</div>
                        <div class="hint-reason">${reason}</div>
                        <button id="got-it-btn" class="mt-4 utility-btn">Got it!</button>
                    </div>
                `);

                this.showModal('hint');
                document.getElementById('got-it-btn').addEventListener('click', () => {
                    this.closeModal('hint');
                });
            }

            explainCardChoice(card, player, trick, trumpSuit) {
                const trickCards = trick.map(p => p.card);
                const playableCards = player.getPlayableCards(trickCards, trumpSuit);

                // Leading the trick
                if (trick.length === 0) {
                    if (card.rank === 'Rook' || card.suit === trumpSuit) {
                        return "Lead with trump to pull opponent's trump cards and establish control.";
                    }
                    const suitCounts = SUITS.reduce((acc, s) => ({...acc, [s]: player.hand.filter(c => c.suit === s).length}), {});
                    if (suitCounts[card.suit] === 1) {
                        return "Lead your singleton to create a void, allowing you to trump this suit later.";
                    }
                    return "Lead low from this suit to preserve higher cards for later.";
                }

                // Following suit
                const winnerInfo = this.determineTrickWinner(trick);
                const partnerIsWinning = winnerInfo && winnerInfo.player.id === player.partnerId;

                if (partnerIsWinning) {
                    if (card.value > 0) {
                        return `Partner is winning! "Smear" your ${card.value}-point card to help your team score.`;
                    }
                    return "Partner is winning. Play your lowest card to save better cards for later.";
                }

                // Try to win
                const trickValue = trickCards.reduce((sum, c) => sum + c.value, 0);
                const canWin = card.rank === 'Rook' ||
                    (trumpSuit && card.suit === trumpSuit && (!winnerInfo.card.suit === trumpSuit || card.power > winnerInfo.card.power));

                if (canWin) {
                    if (trickValue >= 15) {
                        return `Take this valuable trick (${trickValue} points) with your ${card.rank === 'Rook' ? 'Rook' : card.suit + ' ' + card.rank}.`;
                    }
                    return "Win this trick cheaply with your lowest winning card.";
                }

                if (card.value > 0 && trickValue >= 10) {
                    return `You can't win, but smear your ${card.value}-point card since opponents are taking points anyway.`;
                }

                return "You can't win this trick. Play your lowest card to save better cards.";
            }

            loadStats() {
                const saved = localStorage.getItem('rookGameStats');
                if (saved) {
                    return JSON.parse(saved);
                }
                return {
                    gamesPlayed: 0,
                    gamesWon: 0,
                    totalBids: 0,
                    successfulBids: 0,
                    shootTheMoonAttempts: 0,
                    shootTheMoonSuccesses: 0,
                    highestScore: 0,
                    mostPointsInHand: 0,
                    byDifficulty: {
                        easy: { wins: 0, games: 0 },
                        medium: { wins: 0, games: 0 },
                        hard: { wins: 0, games: 0 }
                    }
                };
            }

            saveStats() {
                localStorage.setItem('rookGameStats', JSON.stringify(this.stats));
            }

            updateStats(won) {
                this.stats.gamesPlayed++;
                if (won) this.stats.gamesWon++;
                if (this.difficulty) {
                    this.stats.byDifficulty[this.difficulty].games++;
                    if (won) this.stats.byDifficulty[this.difficulty].wins++;
                }
                const finalScore = Math.max(this.scores.team1, this.scores.team2);
                if (finalScore > this.stats.highestScore) {
                    this.stats.highestScore = finalScore;
                }
                this.saveStats();
            }

            showStats() {
                const stats = this.stats;
                const winRate = stats.gamesPlayed > 0 ? ((stats.gamesWon / stats.gamesPlayed) * 100).toFixed(1) : 0;
                const bidSuccessRate = stats.totalBids > 0 ? ((stats.successfulBids / stats.totalBids) * 100).toFixed(1) : 0;

                const easyWinRate = stats.byDifficulty.easy.games > 0 ?
                    ((stats.byDifficulty.easy.wins / stats.byDifficulty.easy.games) * 100).toFixed(1) : 0;
                const mediumWinRate = stats.byDifficulty.medium.games > 0 ?
                    ((stats.byDifficulty.medium.wins / stats.byDifficulty.medium.games) * 100).toFixed(1) : 0;
                const hardWinRate = stats.byDifficulty.hard.games > 0 ?
                    ((stats.byDifficulty.hard.wins / stats.byDifficulty.hard.games) * 100).toFixed(1) : 0;

                this.dom.statsModal.innerHTML = this.createModalContent('ðŸ“Š Your Statistics', `
                    <div class="text-white p-4">
                        <div class="mb-6">
                            <h3 class="text-xl font-bold mb-3 text-yellow-400">Overall Stats</h3>
                            <div class="grid grid-cols-2 gap-4 text-sm">
                                <div><strong>Games Played:</strong> ${stats.gamesPlayed}</div>
                                <div><strong>Win Rate:</strong> ${winRate}%</div>
                                <div><strong>Games Won:</strong> ${stats.gamesWon}</div>
                                <div><strong>Highest Score:</strong> ${stats.highestScore}</div>
                            </div>
                        </div>

                        <div class="mb-6">
                            <h3 class="text-xl font-bold mb-3 text-yellow-400">Bidding</h3>
                            <div class="grid grid-cols-2 gap-4 text-sm">
                                <div><strong>Total Bids:</strong> ${stats.totalBids}</div>
                                <div><strong>Success Rate:</strong> ${bidSuccessRate}%</div>
                                <div><strong>Shoot the Moon:</strong> ${stats.shootTheMoonAttempts} attempts</div>
                                <div><strong>STM Success:</strong> ${stats.shootTheMoonSuccesses}</div>
                            </div>
                        </div>

                        <div>
                            <h3 class="text-xl font-bold mb-3 text-yellow-400">By Difficulty</h3>
                            <div class="space-y-2 text-sm">
                                <div><strong>vs Easy:</strong> ${easyWinRate}% (${stats.byDifficulty.easy.wins}/${stats.byDifficulty.easy.games})</div>
                                <div><strong>vs Medium:</strong> ${mediumWinRate}% (${stats.byDifficulty.medium.wins}/${stats.byDifficulty.medium.games})</div>
                                <div><strong>vs Hard:</strong> ${hardWinRate}% (${stats.byDifficulty.hard.wins}/${stats.byDifficulty.hard.games})</div>
                            </div>
                        </div>

                        <button id="close-stats-btn" class="mt-6 utility-btn">Close</button>
                        <button id="reset-stats-btn" class="mt-6 utility-btn bg-red-600 hover:bg-red-700">Reset Stats</button>
                    </div>
                `);

                this.showModal('stats');
                document.getElementById('close-stats-btn').addEventListener('click', () => this.closeModal('stats'));
                document.getElementById('reset-stats-btn').addEventListener('click', () => {
                    if (confirm('Are you sure you want to reset all statistics?')) {
                        this.stats = this.loadStats();
                        localStorage.removeItem('rookGameStats');
                        this.closeModal('stats');
                        this.showStats();
                    }
                });
            }

            initModals() {
                this.dom.difficultyModal.innerHTML = this.createModalContent('Select Difficulty', `
                    <div class="flex flex-col gap-4">
                        <div class="flex gap-4 justify-center">
                            <button data-difficulty="easy">Easy</button>
                            <button data-difficulty="medium">Medium</button>
                            <button data-difficulty="hard">Hard</button>
                        </div>
                        <div class="flex gap-4 justify-center">
                            <button id="view-rules-btn" class="utility-btn bg-blue-500 hover:bg-blue-600 mt-4">View Rules</button>
                            <button id="view-strategy-btn" class="utility-btn bg-green-500 hover:bg-green-600 mt-4">Learn</button>
                            <button data-difficulty="practice" class="utility-btn bg-purple-500 hover:bg-purple-600 mt-4">Practice</button>
                        </div>
                    </div>`);
                this.dom.biddingModal.innerHTML = this.createModalContent('Your Bid', `
                    <div class="bidding-section-label">The Nest (5 cards)</div>
                    <div id="bidding-nest-display"></div>

                    <div id="hand-strength-indicator" class="hidden mt-4 p-3 rounded-lg border-2 text-center">
                        <div class="text-sm font-semibold mb-1">Hand Strength</div>
                        <div id="strength-bar-container" class="w-full h-6 bg-gray-700 rounded-full overflow-hidden mb-2">
                            <div id="strength-bar" class="h-full transition-all duration-500" style="width: 0%"></div>
                        </div>
                        <div id="strength-label" class="text-lg font-bold"></div>
                        <div id="strength-suggestion" class="text-xs mt-1 text-gray-300"></div>
                    </div>

                    <p class="mb-2 mt-4">Current Bid: <span id="current-bid-display"></span></p>
                    <div id="bid-options" class="flex items-center justify-center">
                        <input type="number" id="bid-input" class="p-2 rounded" min="90" max="180" step="5">
                        <button id="submit-bid-button">Bid</button>
                    </div>
                    <div class="mt-4">
                        <button id="pass-button">Pass</button>
                        <button id="shoot-moon-button" class="bg-red-600 hover:bg-red-700">Shoot the Moon!</button>
                    </div>

                    <div class="bidding-section-label">Your Hand</div>
                    <div id="bidding-hand-display"></div>
                `);
                this.dom.trumpModal.innerHTML = this.createModalContent('Name the Trump Suit', `
                    <div id="trump-options" class="flex gap-4 justify-center">
                        <button data-suit="Black" class="trump-suit-btn" style="background: linear-gradient(145deg, var(--black-suit), #1a1a1a); color: white; border: 2px solid var(--black-suit);">B</button>
                        <button data-suit="Red" class="trump-suit-btn" style="background: linear-gradient(145deg, var(--red-suit), #c0392b); color: white; border: 2px solid var(--red-suit);">R</button>
                        <button data-suit="Green" class="trump-suit-btn" style="background: linear-gradient(145deg, var(--green-suit), #219a52); color: white; border: 2px solid var(--green-suit);">G</button>
                        <button data-suit="Yellow" class="trump-suit-btn" style="background: linear-gradient(145deg, var(--yellow-suit), #e67e22); color: black; border: 2px solid var(--yellow-suit);">Y</button>
                    </div>`);
                this.dom.buryModal.innerHTML = this.createModalContent('Create the Widow', `
                         <p>Select 5 cards from your hand to place in the Widow.</p>
                         <p>Selected: <span id="bury-count">0</span> / 5</p>
                         <button id="bury-confirm-button" class="mt-4" disabled>Confirm</button>`);
                
                const roundSummaryContent = `
                    <div id="round-summary-container" class="w-full max-w-2xl text-white p-4">
                        <div class="grid grid-cols-6 gap-4 text-center border-b border-gray-500 pb-2 font-bold text-gray-300">
                            <div>Team 1</div>
                            <div>Team 2</div>
                            <div>Dealer</div>
                            <div>High Bid</div>
                            <div>Trump</div>
                            <div>Rook</div>
                        </div>
                        <div class="grid grid-cols-6 gap-4 text-center pt-4 text-lg items-center">
                            <div id="summary-team1-score" class="font-bold text-2xl"></div>
                            <div id="summary-team2-score" class="font-bold text-2xl"></div>
                            <div id="summary-dealer"></div>
                            <div id="summary-high-bid" class="text-sm"></div>
                            <div id="summary-trump"></div>
                            <div id="summary-rook"></div>
                        </div>
                    </div>
                    <button id="continue-button" class="mt-8">Continue</button>
                `;
                this.dom.roundSummaryModal.innerHTML = this.createModalContent('Round Summary', roundSummaryContent);

                this.dom.lastTrickModal.innerHTML = this.createModalContent('Last Trick', `<div id="last-trick-display" class="last-trick-display"></div><button id="close-last-trick" class="mt-4">Close</button>`);
                this.dom.settingsModal.innerHTML = this.createModalContent('Settings', `
                    <div class="flex flex-col gap-6 items-center">
                        <div>
                            <label for="winning-score-input" class="block mb-2">Winning Score:</label>
                            <input type="number" id="winning-score-input" class="p-2 rounded w-24" value="${WINNING_SCORE}" step="50">
                        </div>
                        <div>
                            <p class="block mb-2">Organize Hand By:</p>
                            <div class="flex gap-4">
                                <label><input type="radio" name="sortOrder" value="desc" ${this.handSortOrder === 'desc' ? 'checked' : ''}> Descending</label>
                                <label><input type="radio" name="sortOrder" value="asc" ${this.handSortOrder === 'asc' ? 'checked' : ''}> Ascending</label>
                            </div>
                        </div>
                        <button id="save-settings-btn">Save</button>
                    </div>`);
                
                const rulesContent = `
                    <div class="text-left max-h-96 overflow-y-auto pr-4">
                        <h3 class="text-xl font-bold mb-2">Object of the Game</h3>
                        <p>To be the first team to reach a predetermined number of points (default 500). Points are scored by capturing cards with point values in tricks.</p>
                        
                        <h3 class="text-xl font-bold mt-4 mb-2">The Cards & Values</h3>
                        <ul>
                            <li>- The Rook Bird card is the highest trump.</li>
                            <li>- 1s are worth 15 points.</li>
                            <li>- 14s (high) & 10s are worth 10 points.</li>
                            <li>- 5s are worth 5 points.</li>
                            <li>- Other cards have no point value.</li>
                        </ul>

                        <h3 class="text-xl font-bold mt-4 mb-2">The Deal</h3>
                        <p>Each player receives 10 cards. A 5-card "nest" is placed on the table.</p>

                        <h3 class="text-xl font-bold mt-4 mb-2">Bidding</h3>
                        <p>Players bid for the privilege of naming the trump suit. The minimum bid is 90. The player who wins the bid takes the 5 cards from the nest, then discards 5 cards. These discarded cards are called the "widow".</p>

                        <h3 class="text-xl font-bold mt-4 mb-2">Playing the Hand</h3>
                        <p>The high bidder leads the first trick. You must follow the suit led if you can. If you cannot follow suit, you may play any card, including a trump card. The highest card of the suit led wins the trick, unless a trump is played, in which case the highest trump card wins.</p>

                        <h3 class="text-xl font-bold mt-4 mb-2">Scoring</h3>
                        <p>At the end of the hand, each team counts the points from the cards they've captured (including the widow for the winning team). If the bidding team meets their bid, they score all the points they took. If they fail, they are "set" and their bid amount is subtracted from their score. The non-bidding team always scores the points they took.</p>
                    </div>
                    <button id="close-rules-btn" class="mt-4">Close</button>
                `;
                this.dom.rulesModal.innerHTML = this.createModalContent('Game Rules', rulesContent);
                const strategyContent = `
                    <div class="text-left max-h-96 overflow-y-auto pr-4">
                        <h3 class="text-xl font-bold mb-2">Bidding Strategy</h3>
                        <p>A good bid is based on the number of trump cards you have, high point cards (1s, 14s, 10s), and the Rook. A common rule of thumb is to count 20-25 points for the Rook, 15 for each Ace (1), and 5-10 for each trump card over 3. If you have a void (no cards of a suit), you can bid higher.</p>
                        
                        <h3 class="text-xl font-bold mt-4 mb-2">Creating the Widow</h3>
                        <p>After winning the bid, your goal is to create the strongest hand possible. Generally, you want to discard non-trump, low-value cards. Getting rid of an entire suit (creating a void) is a powerful strategy, as it allows you to trump when that suit is led.</p>

                        <h3 class="text-xl font-bold mt-4 mb-2">Playing Strategy</h3>
                        <p>If you have the lead and a strong trump suit, it's often wise to lead with high trumps to "pull out" your opponents' trumps. If your partner has won the trick, try to discard a high-point card of a different suit to give them extra points. Pay attention to what's been played!</p>
                    </div>
                    <button id="close-strategy-btn" class="mt-4">Close</button>
                `;
                this.dom.strategyModal.innerHTML = this.createModalContent('Game Strategy', strategyContent);

                this.dom.difficultyModal.addEventListener('click', e => {
                    if (e.target.dataset.difficulty) {
                        this.difficulty = e.target.dataset.difficulty;
                        // Hide card tracker on hard mode, show on easy/medium/practice
                        if (this.difficulty === 'hard') {
                            this.dom.cardTracker.classList.add('hidden-hard');
                        } else {
                            this.dom.cardTracker.classList.remove('hidden-hard');
                        }
                        this.hideModal('difficulty');
                        this.startNewGame();
                    } else if (e.target.id === 'view-rules-btn') {
                        this.showModal('rules');
                    } else if (e.target.id === 'view-strategy-btn') {
                        this.showModal('strategy');
                    }
                });
                this.dom.rulesModal.addEventListener('click', e => {
                    if (e.target.id === 'close-rules-btn') {
                        this.hideModal('rules');
                    }
                });
                this.dom.strategyModal.addEventListener('click', e => {
                    if (e.target.id === 'close-strategy-btn') {
                        this.hideModal('strategy');
                    }
                });
                this.dom.roundSummaryModal.addEventListener('click', e => {
                    if (e.target.id === 'continue-button') {
                        this.hideModal('roundSummary');
                        if (this.scores.team1 >= WINNING_SCORE || this.scores.team2 >= WINNING_SCORE) {
                            const won = this.scores.team1 >= WINNING_SCORE;
                            this.updateStats(won);
                            this.showMessage(`${won ? "You and your Partner" : "The Opponents"} win the game!`, 5000);
                            setTimeout(() => this.showModal('difficulty'), 5000);
                        } else {
                            this.startNewHand();
                        }
                    }
                });
                this.dom.lastTrickModal.addEventListener('click', e => {
                    if (e.target.id === 'close-last-trick') {
                        this.hideModal('lastTrick');
                    }
                });
                this.dom.settingsModal.addEventListener('click', e => {
                    if (e.target.id === 'save-settings-btn') {
                        const newScore = document.getElementById('winning-score-input').value;
                        WINNING_SCORE = parseInt(newScore, 10) || 500;
                        
                        const newSortOrder = document.querySelector('input[name="sortOrder"]:checked').value;
                        this.handSortOrder = newSortOrder;
                        this.players.forEach(p => p.sortHand(this.trumpSuit, this.handSortOrder));
                        this.renderAllHands();

                        this.showMessage(`Settings saved!`, 2000);
                        this.hideModal('settings');
                    }
                });
            }

            createModalContent(title, body) {
                return `<div class="modal-content"><h2 class="text-2xl font-bold mb-4">${title}</h2>${body}</div>`;
            }

            showModal(modalName) { this.dom[modalName + 'Modal'].classList.add('active'); }
            hideModal(modalName) { this.dom[modalName + 'Modal'].classList.remove('active'); }

            startNewGame() {
                this.scores = { team1: 0, team2: 0 };
                this.dealerIndex = 3;
                this.handHistory = [];
                this.updateScoreboard();
                this.startNewHand();
            }

            startNewHand() {
                this.currentHandData = { rookWinner: null };
                this.lastTrick = [];
                this.trickHistory = [];
                this.updateCardTracker(); // Reset card tracker for new hand
                this.isFolded = false;
                this.dom.seeLastTrickBtn.disabled = true;
                this.dom.postBuryActions.classList.add('hidden');
                this.updateLiveSummary();
                this.dom.gameSummaryBox.classList.remove('hidden');
                // Expand panel at start of hand so players can see bidding/dealer info
                this.dom.gameSummaryBox.classList.remove('collapsed');
                // Reset position to default (top-left)
                this.resetSummaryBoxPosition();
                this.dom.trickArea.innerHTML = '';
                this.dom.nestDisplay.innerHTML = '';
                this.dom.widowOnTable.innerHTML = '';
                this.dom.trumpIndicator.classList.add('hidden');
                this.dealerIndex = (this.dealerIndex + 1) % 4;
                this.currentHandData.dealer = this.dealerIndex;
                this.updateLiveSummary('dealer');
                this.deck = new Deck(); this.deck.shuffle();
                const { hands, nest } = this.deck.deal(4, 10);
                this.nest = nest;
                this.widow = [];
                this.dom.infos.forEach((info, i) => {
                    info.classList.remove('font-bold', 'text-yellow-300', 'high-bidder');
                    let playerName;
                    if (i === 0) playerName = 'You';
                    else if (i === 1) playerName = 'Player 1';
                    else if (i === 2) playerName = 'Partner';
                    else if (i === 3) playerName = 'Player 4';
                    
                    if (i === this.dealerIndex) {
                        info.innerHTML = `${playerName} <span class="dealer-marker">(D)</span>`;
                    } else {
                        info.textContent = playerName;
                    }
                });
                this.players.forEach((player, i) => { player.hand = hands[i]; player.sortHand(null, this.handSortOrder); });
                this.renderNest();
                this.renderAllHands(true);
                setTimeout(() => { this.renderAllHands(false); this.startBidding(); }, 2000);
            }
            
            async startBidding() {
                this.highBid = 85; this.highBidder = null;
                this.previousBid = 85; // Track previous bid for partner logic
                this.players.forEach(p => p.hasPassed = false);
                this.bidTurnIndex = (this.dealerIndex + 1) % 4;
                this.biddingRound = 0;
                while (this.players.filter(p => !p.hasPassed).length > 1) {
                    const player = this.players[this.bidTurnIndex];
                    if (player.hasPassed) { this.bidTurnIndex = (this.bidTurnIndex + 1) % 4; continue; }
                    this.dom.infos.forEach(info => info.classList.remove('font-bold', 'text-yellow-300'));
                    this.dom.infos[this.bidTurnIndex].classList.add('font-bold', 'text-yellow-300');
                    const hasShootOpt = this.biddingRound < 4;
                    let bid;
                    if (player.isHuman) {
                        bid = await this.getHumanBid(hasShootOpt);
                    } else {
                        await this.sleep(1500);
                        if (this.difficulty === 'hard') {
                            bid = player.getAdvancedBid(this.highBid, hasShootOpt, this.highBidder, this.previousBid);
                        } else {
                            bid = player.getBid(this.highBid, hasShootOpt, this.difficulty, this.highBidder, this.previousBid);
                        }
                        this.showMessage(`${this.dom.infos[player.id].textContent} bids ${bid}`, 1400);
                    }

                    this.dom.infos.forEach(info => info.classList.remove('high-bidder'));
                    if (bid === 'shoot') { this.previousBid = this.highBid; this.highBid = 'shoot'; this.highBidder = player; this.dom.infos[this.players.indexOf(this.highBidder)].classList.add('high-bidder'); break; }
                    else if (bid === 'pass') { player.hasPassed = true; }
                    else { this.previousBid = this.highBid; this.highBid = bid; this.highBidder = player; this.dom.infos[this.players.indexOf(this.highBidder)].classList.add('high-bidder');}
                    this.bidTurnIndex = (this.bidTurnIndex + 1) % 4; this.biddingRound++;
                }
                if (!this.highBidder) { this.highBidder = this.players.find(p => !p.hasPassed) || this.players[this.dealerIndex]; this.highBid = this.highBidder ? this.highBid : 90; if(!this.highBidder) this.highBidder = this.players[this.dealerIndex]; this.dom.infos[this.players.indexOf(this.highBidder)].classList.add('high-bidder'); }
                
                this.currentHandData.highBidder = this.dom.infos[this.highBidder.id].textContent;
                this.currentHandData.bidAmount = this.highBid;
                this.updateLiveSummary('bid');

                if (this.highBid === 'shoot') { this.showMessage(`${this.currentHandData.highBidder} is Shooting the Moon!`, 2000); this.highBid = 180; this.isShootingMoon = true; }
                else { this.showMessage(`${this.currentHandData.highBidder} won with ${this.highBid}`, 2000); this.isShootingMoon = false; }
                await this.sleep(2000); 
                this.handleNestAndTrump();
            }
            
            async handleNestAndTrump() {
                this.isFolded = false; 
                await this.revealNest();
                this.highBidder.hand.push(...this.nest);
                
                let trump;
                if (this.highBidder.isHuman) {
                    this.highBidder.sortHand(null, this.handSortOrder);
                    this.renderPlayerHand(this.highBidder.id, false, true);
                    await this.getHumanBury();
                    this.renderPlayerHand(this.highBidder.id);

                    const choice = await this.getHumanPostBuryChoice();

                    if (choice === 'fold') {
                        this.isFolded = true;
                        this.currentHandData.bidAmount = `${this.highBid} (Fold)`;
                        this.showMessage(`${this.dom.infos[this.highBidder.id].textContent} folds.`, 2000);
                        await this.sleep(2000);
                        this.endHand();
                        return; 
                    } else if (choice === 'ask') {
                        const partner = this.players[this.highBidder.partnerId];
                        this.showMessage(`Asking partner to call trump...`, 2000);
                        await this.sleep(2000);
                        trump = partner.chooseTrump();
                        this.showMessage(`Partner calls ${trump}!`, 2000);
                        await this.sleep(1000);
                    } else if (choice === 'no-trump') {
                        trump = null;
                    } else { // 'call'
                        trump = await this.getHumanTrump();
                    }
                } else {
                    if (this.difficulty === 'hard') {
                        const { trumpSuit, buriedCards } = this.highBidder.chooseAdvancedTrumpAndBury();
                        this.widow = buriedCards;
                        trump = trumpSuit;
                    } else {
                        const counts = SUITS.reduce((acc, suit) => { acc[suit] = this.highBidder.hand.filter(c => c.suit === suit).length; return acc; }, {});
                        trump = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
                        this.setTrump(trump);
                        const toBury = this.highBidder.chooseCardsToBury(this.difficulty);
                        this.widow = toBury;
                        this.highBidder.hand = this.highBidder.hand.filter(c => !toBury.includes(c));
                    }
                    this.showMessage(`${this.dom.infos[this.highBidder.id].textContent} creates the widow.`, 1500);
                }
                
                this.renderPlayerHand(this.highBidder.id); 
                this.renderWidowOnTable(); 
                await this.sleep(1500);
                this.setTrump(trump);
                await this.sleep(1500);
                this.startTrickPlay();
            }
            
            async startTrickPlay() {
                // Auto-collapse the game info panel to keep it out of the way during gameplay
                const box = this.dom.gameSummaryBox;
                if (!box.classList.contains('collapsed')) {
                    box.classList.add('collapsed');
                    const toggle = box.querySelector('.collapse-toggle');
                    const header = box.querySelector('.game-summary-header');
                    if (toggle) toggle.textContent = '+';
                    if (header) header.classList.add('collapsed-only');
                }

                this.trickLeaderIndex = this.players.indexOf(this.highBidder);
                this.team1Tricks = []; this.team2Tricks = [];
                this.trickHistory = [];
                for (let i = 0; i < 10; i++) { await this.playTrick(); }
                this.endHand();
            }
            
            async playTrick() {
                this.currentTrick = []; this.dom.trickArea.innerHTML = '';
                for (let i = 0; i < 4; i++) {
                    const pIndex = (this.trickLeaderIndex + i) % 4; const player = this.players[pIndex];
                    this.dom.infos.forEach(info => info.classList.remove('font-bold', 'text-yellow-300'));
                    this.dom.infos[pIndex].classList.add('font-bold', 'text-yellow-300');
                    let playedCard;
                    if (player.isHuman) {
                        // Save state for undo (practice mode only)
                        if (this.difficulty === 'practice') {
                            this.undoState = {
                                hand: [...player.hand],
                                currentTrick: [...this.currentTrick],
                                trickLeaderIndex: this.trickLeaderIndex,
                                loopIndex: i
                            };
                        }

                        // Show hint button for easy/medium/practice difficulty
                        if (this.difficulty !== 'hard') {
                            this.dom.hintBtn.classList.remove('hidden');
                        }
                        playedCard = await this.getHumanCardPlay();
                        this.dom.hintBtn.classList.add('hidden');

                        // Show undo button after human plays (practice mode only, not last card in trick)
                        if (this.difficulty === 'practice' && i < 3) {
                            this.dom.undoBtn.classList.remove('hidden');
                        }
                    } else {
                        // Hide undo button when AI plays (they've committed their play)
                        this.dom.undoBtn.classList.add('hidden');

                        await this.sleep(1000);
                        if (this.difficulty === 'hard') {
                            const gameState = {
                                scores: this.scores,
                                highBid: this.highBid,
                                highBidderId: this.highBidder.id,
                                team1Tricks: this.team1Tricks,
                                team2Tricks: this.team2Tricks,
                                widowValue: this.widow.reduce((sum, c) => sum + c.value, 0)
                            };
                            playedCard = player.playAdvancedCard(this.currentTrick, this.trumpSuit, this.trickHistory, gameState);
                        } else {
                             playedCard = player.playCard(this.currentTrick, this.trumpSuit, this.difficulty);
                        }
                    }
                    player.hand = player.hand.filter(c => c.id !== playedCard.id); this.renderPlayerHand(pIndex);
                    this.currentTrick.push({ card: playedCard, player: player }); this.renderTrick(); await this.sleep(500);
                }
                const winnerInfo = this.determineTrickWinner(this.currentTrick);
                this.trickLeaderIndex = winnerInfo.player.id;
                
                if (this.currentTrick.some(p => p.card.rank === 'Rook')) {
                    this.currentHandData.rookWinner = this.dom.infos[winnerInfo.player.id].textContent;
                    this.currentHandData.rookWinnerId = winnerInfo.player.id;
                    this.updateLiveSummary('rook');
                    this.positionSummaryBoxNearPlayer(winnerInfo.player.id);
                }
                
                this.lastTrick = [...this.currentTrick];
                this.trickHistory.push(this.lastTrick);
                this.updateCardTracker(); // Update tracker after each trick
                this.dom.seeLastTrickBtn.disabled = false;

                // Hide undo button after trick completes
                this.dom.undoBtn.classList.add('hidden');
                this.undoState = null;

                // Enhanced feedback message
                const captured = this.currentTrick.map(p => p.card);
                const pointsInTrick = captured.reduce((sum, c) => sum + c.value, 0);
                const winnerName = this.dom.infos[winnerInfo.player.id].textContent;
                const winningCard = winnerInfo.card;

                let reason = '';
                if (winningCard.rank === 'Rook') {
                    reason = 'with Rook (highest card!)';
                } else if (this.trumpSuit && winningCard.suit === this.trumpSuit) {
                    const leadCard = this.currentTrick[0].card;
                    if (leadCard.suit !== this.trumpSuit || leadCard.rank === 'Rook') {
                        reason = `with ${this.trumpSuit} ${winningCard.rank === 1 ? 'Ace' : winningCard.rank} (trump!)`;
                    } else {
                        reason = `with ${this.trumpSuit} ${winningCard.rank === 1 ? 'Ace' : winningCard.rank}`;
                    }
                } else {
                    reason = `with ${winningCard.suit} ${winningCard.rank === 1 ? 'Ace' : winningCard.rank}`;
                }

                const pointMsg = pointsInTrick > 0 ? ` (${pointsInTrick} points!)` : '';
                this.showMessage(`${winnerName} wins ${reason}${pointMsg}`, 1500);

                if (winnerInfo.player.id === 0 || winnerInfo.player.id === 2) { this.team1Tricks.push(...captured); } else { this.team2Tricks.push(...captured); }
                
                // Animate trick cards flying off to the "See Last Trick" button
                await this.animateTrickCollection();
                
                await this.sleep(1000);
            }
            
            determineTrickWinner(trick) {
                if (!trick || trick.length === 0) return null;
                
                const rookPlay = trick.find(p => p.card.rank === 'Rook');
                if (rookPlay) return { player: rookPlay.player, card: rookPlay.card };
                
                let winningPlay = trick[0];
                const leadSuit = winningPlay.card.suit;

                if (this.trumpSuit === null) { // No Trump logic
                    for (let i = 1; i < trick.length; i++) {
                        const currentPlay = trick[i];
                        if (currentPlay.card.suit === leadSuit && currentPlay.card.power > winningPlay.card.power) {
                            winningPlay = currentPlay;
                        }
                    }
                } else { // Standard Trump logic
                    const leadSuitIsTrump = leadSuit === this.trumpSuit;
                    for (let i = 1; i < trick.length; i++) {
                        const currentPlay = trick[i];
                        const winningCard = winningPlay.card;
                        const currentCard = currentPlay.card;

                        const winningCardIsTrump = winningCard.suit === this.trumpSuit;
                        const currentCardIsTrump = currentCard.suit === this.trumpSuit;

                        if (winningCardIsTrump) {
                            if (currentCardIsTrump && currentCard.power > winningCard.power) {
                                winningPlay = currentPlay;
                            }
                        } else {
                            if (currentCardIsTrump) {
                                winningPlay = currentPlay;
                            } else if (currentCard.suit === leadSuit && currentCard.power > winningCard.power) {
                                winningPlay = currentPlay;
                            }
                        }
                    }
                }
                return { player: winningPlay.player, card: winningPlay.card };
            }
            
            endHand() {
                this.dom.trickArea.innerHTML = '';

                if (this.isFolded) {
                    const bidTeam = (this.highBidder.id === 0 || this.highBidder.id === 2) ? 1 : 2;
                    if (bidTeam === 1) {
                        this.scores.team1 -= this.highBid;
                        this.currentHandData.team1Score = `-${this.highBid}`;
                        this.currentHandData.team2Score = 0;
                    } else {
                        this.scores.team2 -= this.highBid;
                        this.currentHandData.team2Score = `-${this.highBid}`;
                        this.currentHandData.team1Score = 0;
                    }
                    this.handHistory.push(this.currentHandData);
                    this.updateScoreboard();
                    this.showRoundSummary();
                    return;
                }

                if (this.trickLeaderIndex === 0 || this.trickLeaderIndex === 2) { this.team1Tricks.push(...this.widow); } else { this.team2Tricks.push(...this.widow); }
                const t1s = this.team1Tricks.reduce((s, c) => s + c.value, 0), t2s = this.team2Tricks.reduce((s, c) => s + c.value, 0);
                const bidTeamId = this.players.indexOf(this.highBidder), bidTeam = (bidTeamId === 0 || bidTeamId === 2) ? 1 : 2;
                
                this.currentHandData.team1Score = 0; this.currentHandData.team2Score = 0;

                if (bidTeam === 1) {
                    if (this.isShootingMoon) { if (t1s === 180) { this.scores.team1 = WINNING_SCORE; this.currentHandData.team1Score = "WIN"; } else { this.scores.team1 -= 180; this.currentHandData.team1Score = -180; } }
                    else { if (t1s >= this.highBid) { this.scores.team1 += t1s; this.currentHandData.team1Score = t1s; } else { this.scores.team1 -= this.highBid; this.currentHandData.team1Score = `-${this.highBid}`; } this.scores.team2 += t2s; this.currentHandData.team2Score = t2s; }
                } else {
                    if (this.isShootingMoon) { if (t2s === 180) { this.scores.team2 = WINNING_SCORE; this.currentHandData.team2Score = "WIN"; } else { this.scores.team2 -= 180; this.currentHandData.team2Score = -180; } }
                    else { if (t2s >= this.highBid) { this.scores.team2 += t2s; this.currentHandData.team2Score = t2s; } else { this.scores.team2 -= this.highBid; this.currentHandData.team2Score = `-${this.highBid}`; } this.scores.team1 += t1s; this.currentHandData.team1Score = t1s; }
                }
                
                this.handHistory.push(this.currentHandData);
                this.updateScoreboard();
                this.showRoundSummary();
            }
            
            async animateTrickCollection() {
                const trickCards = Array.from(this.dom.trickArea.children);
                const seeLastTrickBtn = this.dom.seeLastTrickBtn;
                const btnRect = seeLastTrickBtn.getBoundingClientRect();
                
                // Animate each card flying to the button position
                const animations = trickCards.map((card, index) => {
                    return new Promise(resolve => {
                        // Get current card position
                        const cardRect = card.getBoundingClientRect();
                        
                        // Calculate distance to button
                        const deltaX = btnRect.left + btnRect.width/2 - (cardRect.left + cardRect.width/2);
                        const deltaY = btnRect.top + btnRect.height/2 - (cardRect.top + cardRect.height/2);
                        
                        // Apply animation
                        card.style.transition = 'all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                        card.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(0.3) rotate(${Math.random() * 360}deg)`;
                        card.style.opacity = '0.8';
                        card.style.zIndex = '200';
                        
                        setTimeout(() => {
                            card.style.opacity = '0';
                            setTimeout(resolve, 200);
                        }, 400);
                    });
                });
                
                // Wait for all animations to complete
                await Promise.all(animations);
                
                // Clear the trick area
                this.dom.trickArea.innerHTML = '';
            }
            
            showRoundSummary() {
                const lastHand = this.handHistory[this.handHistory.length - 1];
                if (!lastHand) return;

                const t1ScoreEl = document.getElementById('summary-team1-score');
                const t2ScoreEl = document.getElementById('summary-team2-score');

                const score1 = lastHand.team1Score;
                t1ScoreEl.textContent = score1;
                t1ScoreEl.classList.toggle('text-red-500', String(score1).includes('-'));

                const score2 = lastHand.team2Score;
                t2ScoreEl.textContent = score2;
                t2ScoreEl.classList.toggle('text-red-500', String(score2).includes('-'));

                document.getElementById('summary-dealer').textContent = `P${lastHand.dealer + 1}`;
                
                const bidderName = (lastHand.highBidder || '').replace(' (D)', '');
                document.getElementById('summary-high-bid').textContent = `${lastHand.bidAmount} (${bidderName})`;

                document.getElementById('summary-trump').textContent = lastHand.trumpSuit === null ? 'None' : lastHand.trumpSuit || 'N/A';
                
                const rookWinnerName = (lastHand.rookWinner || '').replace(' (D)', '');
                document.getElementById('summary-rook').textContent = rookWinnerName || 'N/A';

                this.showModal('roundSummary');
            }

            showLastTrick() {
                if (!this.lastTrick || this.lastTrick.length === 0) return;
                const display = document.getElementById('last-trick-display');
                display.innerHTML = '';
                this.lastTrick.forEach(play => {
                    const playContainer = document.createElement('div');
                    playContainer.className = 'flex flex-col items-center gap-2';
                    
                    const cardEl = this.createCardElement(play.card, true);
                    cardEl.style.margin = '0';

                    const playerNameEl = document.createElement('p');
                    playerNameEl.className = 'text-sm font-semibold';
                    let playerName = this.dom.infos[play.player.id].textContent;
                    if (playerName.includes(' (D)')) {
                        playerName = playerName.split(' (D)')[0];
                    }
                    playerNameEl.textContent = playerName;

                    playContainer.appendChild(cardEl);
                    playContainer.appendChild(playerNameEl);
                    display.appendChild(playContainer);
                });
                this.showModal('lastTrick');
            }

            showHandStrength(player) {
                const indicator = document.getElementById('hand-strength-indicator');
                const strengthBar = document.getElementById('strength-bar');
                const strengthLabel = document.getElementById('strength-label');
                const strengthSuggestion = document.getElementById('strength-suggestion');

                // Calculate hand value using simplified bidding logic
                let handValue = 0;

                const hasRook = player.hand.some(c => c.rank === 'Rook');
                handValue += hasRook ? 20 : 0;

                const ones = player.hand.filter(c => c.rank === 1);
                handValue += ones.length * 15;

                const fourteens = player.hand.filter(c => c.rank === 14);
                handValue += fourteens.length * 10;

                const tens = player.hand.filter(c => c.rank === 10);
                handValue += tens.length * 8;

                const fives = player.hand.filter(c => c.rank === 5);
                handValue += fives.length * 5;

                // Analyze suit distribution
                const suitCounts = SUITS.reduce((acc, suit) => {
                    acc[suit] = player.hand.filter(c => c.suit === suit).length;
                    return acc;
                }, {});

                const maxSuitLength = Math.max(...Object.values(suitCounts));
                handValue += maxSuitLength * 5;

                // Nest expectation
                handValue += 8;

                // Determine strength category
                let category, color, percentage, suggestedBid;

                if (handValue < 60) {
                    category = 'Weak';
                    color = '#ef4444'; // red
                    percentage = 20;
                    suggestedBid = 'Consider passing unless partner shows strength';
                } else if (handValue < 75) {
                    category = 'Fair';
                    color = '#f59e0b'; // orange
                    percentage = 40;
                    suggestedBid = 'Bid cautiously: 90-105';
                } else if (handValue < 90) {
                    category = 'Good';
                    color = '#eab308'; // yellow
                    percentage = 60;
                    suggestedBid = 'Reasonable bid: 105-125';
                } else if (handValue < 110) {
                    category = 'Strong';
                    color = '#84cc16'; // lime
                    percentage = 80;
                    suggestedBid = 'Strong bid: 125-145';
                } else {
                    category = 'Excellent';
                    color = '#22c55e'; // green
                    percentage = 100;
                    suggestedBid = 'Very strong: 145-165 or higher';
                }

                // Display the indicator
                indicator.classList.remove('hidden');
                indicator.style.borderColor = color;
                strengthBar.style.width = percentage + '%';
                strengthBar.style.backgroundColor = color;
                strengthLabel.textContent = category;
                strengthLabel.style.color = color;
                strengthSuggestion.textContent = suggestedBid;
            }

            getHumanBid(hasShootOpt) {
                return new Promise(resolve => {
                    const input = document.getElementById('bid-input'), display = document.getElementById('current-bid-display'), submitBtn = document.getElementById('submit-bid-button'), passBtn = document.getElementById('pass-button'), shootBtn = document.getElementById('shoot-moon-button');
                    const nextBid = this.highBid + 5;
                    const highBidderName = this.highBidder ? ` (${this.dom.infos[this.highBidder.id].textContent})` : '';
                    display.innerHTML = `${this.highBid}<span class="text-sm text-gray-400 ml-2">${highBidderName}</span>`;
                    input.value = nextBid; input.min = nextBid;
                    shootBtn.style.display = hasShootOpt ? 'inline-block' : 'none';
                    const cleanup = () => {
                        submitBtn.onclick = null;
                        passBtn.onclick = null;
                        shootBtn.onclick = null;
                        this.hideModal('bidding');
                    };
                    submitBtn.onclick = () => { const val = Number(input.value); if (val >= nextBid && val <= 180 && val % 5 === 0) { cleanup(); resolve(val); } else { this.showMessage("Invalid bid amount.", 1500); } };
                    passBtn.onclick = () => { cleanup(); resolve('pass'); };
                    shootBtn.onclick = () => { cleanup(); resolve('shoot'); };

                    // Populate hand display in bidding modal
                    const handDisplay = document.getElementById('bidding-hand-display');
                    handDisplay.innerHTML = '';
                    const humanPlayer = this.players[0];
                    humanPlayer.hand.forEach(card => {
                        const cardEl = this.createCardElement(card, true);
                        cardEl.style.position = 'relative';
                        cardEl.style.transform = 'none';
                        handDisplay.appendChild(cardEl);
                    });

                    // Populate nest display in bidding modal
                    const nestDisplay = document.getElementById('bidding-nest-display');
                    nestDisplay.innerHTML = '';
                    this.nest.forEach((card, i) => {
                        const isTopCard = i === this.nest.length - 1; // Last card shown face-up
                        const cardEl = this.createCardElement(card, isTopCard);
                        cardEl.style.position = 'relative';
                        cardEl.style.transform = `rotate(${i*8-16}deg)`;
                        cardEl.style.zIndex = i;
                        nestDisplay.appendChild(cardEl);
                    });

                    // Show hand strength indicator for practice mode only
                    if (this.difficulty === 'practice') {
                        this.showHandStrength(humanPlayer);
                    }

                    this.showModal('bidding');
                });
            }
            
            getHumanBury() {
                return new Promise(resolve => {
                    const countEl = document.getElementById('bury-count'), confirmBtn = document.getElementById('bury-confirm-button');
                    this.showModal('bury');
                    let selected = [];
                    const handEl = this.dom.hands[HUMAN_PLAYER_ID];
                    handEl.querySelectorAll('.card').forEach(el => {
                        el.classList.add('cursor-pointer');
                        el.onclick = () => {
                            const id = el.dataset.id;
                            if (selected.includes(id)) { selected = selected.filter(i => i !== id); el.classList.remove('selected-for-bury'); }
                            else if (selected.length < 5) { selected.push(id); el.classList.add('selected-for-bury'); }
                            countEl.textContent = selected.length; confirmBtn.disabled = selected.length !== 5;
                        };
                    });
                    confirmBtn.onclick = () => {
                        const human = this.players[HUMAN_PLAYER_ID];
                        this.widow = human.hand.filter(c => selected.includes(c.id));
                        human.hand = human.hand.filter(c => !selected.includes(c.id));
                        handEl.querySelectorAll('.card').forEach(el => { el.classList.remove('selected-for-bury'); el.onclick = null; });
                        this.hideModal('bury');
                        resolve();
                    };
                });
            }

            getHumanTrump() { 
                return new Promise(resolve => { 
                    this.showModal('trump');
                    const options = document.getElementById('trump-options');
                    
                    const cleanup = () => {
                        options.onclick = null;
                        this.hideModal('trump');
                    };

                    options.onclick = e => { 
                        if (e.target.tagName === 'BUTTON') { 
                            cleanup();
                            resolve(e.target.dataset.suit); 
                        } 
                    };
                }); 
            }

            getHumanPostBuryChoice() {
                return new Promise(resolve => {
                    const actionsContainer = this.dom.postBuryActions;
                    const callBtn = document.getElementById('action-call-trump');
                    const askBtn = document.getElementById('action-ask-partner');
                    const noTrumpBtn = document.getElementById('action-no-trump');
                    const foldBtn = document.getElementById('action-fold');

                    actionsContainer.classList.remove('hidden');

                    const cleanupAndResolve = (choice) => {
                        actionsContainer.classList.add('hidden');
                        callBtn.onclick = null;
                        askBtn.onclick = null;
                        noTrumpBtn.onclick = null;
                        foldBtn.onclick = null;
                        resolve(choice);
                    };

                    callBtn.onclick = () => cleanupAndResolve('call');
                    askBtn.onclick = () => cleanupAndResolve('ask');
                    noTrumpBtn.onclick = () => cleanupAndResolve('no-trump');
                    foldBtn.onclick = () => cleanupAndResolve('fold');
                });
            }
            
            getHumanCardPlay() {
                return new Promise(resolve => {
                    const human = this.players[HUMAN_PLAYER_ID];
                    const playableCards = human.getPlayableCards(this.currentTrick.map(p => p.card), this.trumpSuit);
                    const playableIds = playableCards.map(c => c.id);
                    const handEl = this.dom.hands[HUMAN_PLAYER_ID];

                    const cleanup = () => {
                        handEl.querySelectorAll('.card').forEach(e => {
                            e.classList.remove('playable');
                            e.onclick = null;
                        });
                    };

                    handEl.querySelectorAll('.card').forEach(el => {
                        if (playableIds.includes(el.dataset.id)) {
                            el.classList.add('playable');
                            el.onclick = () => {
                                const cardId = el.dataset.id;
                                cleanup();
                                resolve(human.hand.find(c => c.id === cardId));
                            };
                        }
                    });
                });
            }

            renderAllHands(isDealing = false) { this.players.forEach((p, i) => this.renderPlayerHand(i, isDealing)); }
            renderPlayerHand(id, isDealing = false, isBurying = false) {
                const handEl = this.dom.hands[id]; handEl.innerHTML = '';
                const hand = this.players[id].hand;
                
                handEl.classList.toggle('bury-selection', isBurying);

                const margin = (id === HUMAN_PLAYER_ID || id === 2) ? -48 : -25;
                
                hand.forEach((card, i) => {
                    const cardEl = this.createCardElement(card, this.players[id].isHuman);
                    cardEl.style.margin = `0 ${margin}px`;
                    const zIndex = (id === HUMAN_PLAYER_ID || id === 2) ? i : hand.length - i;
                    cardEl.style.zIndex = zIndex;
                    if (isDealing) {
                        cardEl.style.transform = `translateY(100vh)`;
                        setTimeout(() => { handEl.appendChild(cardEl); cardEl.style.transform = 'none'; }, i * 50 + Math.random() * 50);
                    } else { handEl.appendChild(cardEl); }
                });
            }
            createCardElement(card, isFaceUp) {
                const el = document.createElement('div'); el.className = 'card'; el.dataset.id = card.id; el.dataset.suit = card.suit;
                const rank = card.rank === 'Rook' ? 'ðŸ¦' : card.rank;
                el.innerHTML = `
                    <div class="card-face"><span class="rank">${rank}</span><span class="suit-icon">${rank}</span></div>
                    <div class="card-back-face"><span>ðŸ¦</span></div>`;
                if (!isFaceUp) el.classList.add('is-flipped');
                return el;
            }
            renderTrick() {
                this.dom.trickArea.innerHTML = '';
                this.currentTrick.forEach((play) => {
                    const cardEl = this.createCardElement(play.card, true);
                    const positions = [
                        { top: '58%', left: '50%', transform: 'translate(-50%, -50%)' }, // P0 (Human - bottom)
                        { top: '50%', left: '42%', transform: 'translate(-50%, -50%)' }, // P1 (Left)
                        { top: '42%', left: '50%', transform: 'translate(-50%, -50%)' }, // P2 (Partner - top)
                        { top: '50%', left: '58%', transform: 'translate(-50%, -50%)' }  // P3 (Right)
                    ];
                    const p = positions[play.player.id];
                    cardEl.style.top = p.top; cardEl.style.left = p.left; cardEl.style.transform = p.transform;
                    this.dom.trickArea.appendChild(cardEl);
                });
            }
            renderNest() {
                this.dom.nestDisplay.innerHTML = '';
                this.nest.forEach((card, i) => {
                    const isTopCard = i === this.nest.length - 1;
                    const cardEl = this.createCardElement(card, isTopCard);
                    cardEl.style.transform = `translate(-50%, -50%) rotate(${i*5-10}deg)`;
                    this.dom.nestDisplay.appendChild(cardEl);
                });
            }
            renderWidowOnTable() {
                this.dom.widowOnTable.innerHTML = '';
                const bidderId = this.highBidder.id;

                // Position widow compactly near the player's hand area, out of play zone
                const positions = [
                    { bottom: '15%', left: '5%' },    // P0 (Human) - bottom left, near hand
                    { top: '40%', left: '5%' },       // P1 (Left) - left side, below hand
                    { top: '15%', right: '5%' },      // P2 (Partner) - top right, near hand
                    { top: '40%', right: '5%' }       // P3 (Right) - right side, below hand
                ];
                const pos = positions[bidderId];
                this.dom.widowOnTable.style.top = pos.top || 'auto';
                this.dom.widowOnTable.style.bottom = pos.bottom || 'auto';
                this.dom.widowOnTable.style.left = pos.left || 'auto';
                this.dom.widowOnTable.style.right = pos.right || 'auto';

                // Create compact widow stack
                const widowStack = document.createElement('div');
                widowStack.className = 'widow-stack';

                // Add 5 mini card backs in a tight stack
                for (let i = 0; i < 5; i++) {
                    const cardEl = this.createCardElement(new Card('Special', 'Rook'), false);
                    widowStack.appendChild(cardEl);
                }

                this.dom.widowOnTable.appendChild(widowStack);
            }
            async revealNest() {
                this.showMessage("Revealing the Nest...", 1000);
                await this.sleep(1000);
                this.dom.nestDisplay.innerHTML = '';
                this.nest.forEach((card, i) => {
                    const cardEl = this.createCardElement(card, false);
                    cardEl.style.left = `${20 + i * 15}%`;
                    cardEl.style.top = '50%';
                    cardEl.style.transform = 'translate(-50%, -50%)';
                    this.dom.nestDisplay.appendChild(cardEl);
                });
                
                const nestCards = Array.from(this.dom.nestDisplay.children);
                for(let i = 0; i < nestCards.length; i++) {
                    await this.sleep(200);
                    nestCards[i].classList.remove('is-flipped');
                }
                await this.sleep(2000);
                this.dom.nestDisplay.innerHTML = '';
            }
            setTrump(suit) {
                this.trumpSuit = suit;
                this.players.forEach(p => p.sortHand(this.trumpSuit, this.handSortOrder));
                this.renderAllHands();
                
                this.dom.trumpIndicator.classList.remove('hidden');
                if (suit === null) {
                    this.currentHandData.trumpSuit = 'None';
                    this.showMessage(`No Trump! High card wins.`, 2000);
                    this.dom.trumpIndicator.textContent = 'NT';
                    this.dom.trumpIndicator.style.backgroundColor = '#6c757d';
                    this.dom.trumpIndicator.style.color = 'white';
                } else {
                    this.currentHandData.trumpSuit = suit;
                    this.showMessage(`Trump is ${suit}!`, 2000);
                    this.dom.trumpIndicator.textContent = suit[0];
                    this.dom.trumpIndicator.style.backgroundColor = `var(--${suit.toLowerCase()}-suit)`;
                    this.dom.trumpIndicator.style.color = (suit === 'Yellow' || suit === 'Green') ? 'black' : 'white';
                }
                this.updateLiveSummary('trump');
            }
            updateScoreboard() {
                const formatScore = (score) => {
                    if (score < 0) {
                        return `${score} (in the hole)`;
                    }
                    return score;
                };

                this.dom.gameSummaryBox.innerHTML = `
                    <div class="game-summary-header">
                        <span class="collapsed-info">${this.scores.team1} - ${this.scores.team2}</span>
                        <button class="collapse-toggle" onclick="game.toggleSummaryCollapse()">âˆ’</button>
                    </div>
                    <div class="game-summary-content">
                        <div class="total-scores font-bold mb-1">
                            <div>You/Partner: ${formatScore(this.scores.team1)}</div>
                            <div>Opponents: ${formatScore(this.scores.team2)}</div>
                        </div>
                        <table class="current-hand-info w-full text-left">
                            <tbody>
                                <tr><td>Dealer:</td><td><span id="live-dealer">...</span></td></tr>
                                <tr><td>High Bid:</td><td><span id="live-bid">...</span></td></tr>
                                <tr><td>Trump:</td><td><span id="live-trump">...</span></td></tr>
                                <tr><td>Rook:</td><td><span id="live-rook">...</span></td></tr>
                            </tbody>
                        </table>
                    </div>`;
            }
            showMessage(msg, duration) { this.dom.statusMessage.textContent = msg; this.dom.statusMessage.classList.remove('hidden'); setTimeout(() => this.dom.statusMessage.classList.add('hidden'), duration); }
            updateLiveSummary(field) {
                if (!this.dom.gameSummaryBox.querySelector('#live-dealer')) this.updateScoreboard();
                if (!field || field === 'dealer') { 
                    const dealerEl = document.getElementById('live-dealer');
                    dealerEl.innerHTML = this.currentHandData.dealer != null ? `P${this.currentHandData.dealer + 1}` : '...';
                }
                if (!field || field === 'bid') { document.getElementById('live-bid').textContent = this.currentHandData.bidAmount ? `${this.currentHandData.bidAmount} (${this.currentHandData.highBidder})` : '...'; }
                if (!field || field === 'trump') { document.getElementById('live-trump').textContent = this.currentHandData.trumpSuit === null ? 'None' : this.currentHandData.trumpSuit || '...'; }
                if (!field || field === 'rook') { document.getElementById('live-rook').textContent = this.currentHandData.rookWinner || '...'; }
            }
            toggleSummaryCollapse() {
                const box = this.dom.gameSummaryBox;
                const toggle = box.querySelector('.collapse-toggle');
                const header = box.querySelector('.game-summary-header');

                if (box.classList.contains('collapsed')) {
                    box.classList.remove('collapsed');
                    toggle.textContent = 'âˆ’';
                    header.classList.remove('collapsed-only');
                } else {
                    box.classList.add('collapsed');
                    toggle.textContent = '+';
                    header.classList.add('collapsed-only');
                }
            }

            initSummaryDrag() {
                const box = this.dom.gameSummaryBox;
                let isDragging = false;
                let startX, startY, initialX, initialY;

                const handleStart = (e) => {
                    const target = e.target;
                    if (target.classList.contains('collapse-toggle')) return;

                    isDragging = true;
                    const touch = e.touches ? e.touches[0] : e;
                    startX = touch.clientX;
                    startY = touch.clientY;

                    const rect = box.getBoundingClientRect();
                    initialX = rect.left;
                    initialY = rect.top;

                    box.style.transition = 'none';
                    e.preventDefault();
                };

                const handleMove = (e) => {
                    if (!isDragging) return;

                    const touch = e.touches ? e.touches[0] : e;
                    const deltaX = touch.clientX - startX;
                    const deltaY = touch.clientY - startY;

                    const newX = initialX + deltaX;
                    const newY = initialY + deltaY;

                    const maxX = window.innerWidth - box.offsetWidth;
                    const maxY = window.innerHeight - box.offsetHeight;

                    box.style.left = Math.max(0, Math.min(newX, maxX)) + 'px';
                    box.style.top = Math.max(0, Math.min(newY, maxY)) + 'px';

                    e.preventDefault();
                };

                const handleEnd = () => {
                    if (isDragging) {
                        isDragging = false;
                        box.style.transition = '';
                    }
                };

                box.addEventListener('mousedown', handleStart);
                box.addEventListener('touchstart', handleStart, { passive: false });
                document.addEventListener('mousemove', handleMove);
                document.addEventListener('touchmove', handleMove, { passive: false });
                document.addEventListener('mouseup', handleEnd);
                document.addEventListener('touchend', handleEnd);
            }

            positionSummaryBoxNearPlayer(playerId) {
                const box = this.dom.gameSummaryBox;
                // Remove all position classes
                box.classList.remove('position-player-0', 'position-player-1', 'position-player-2', 'position-player-3');
                // Add the appropriate position class for this player
                box.classList.add(`position-player-${playerId}`);
                // Reset any manual positioning from dragging
                box.style.left = '';
                box.style.top = '';
                box.style.right = '';
                box.style.bottom = '';
                box.style.transform = '';
            }

            resetSummaryBoxPosition() {
                const box = this.dom.gameSummaryBox;
                // Remove all position classes
                box.classList.remove('position-player-0', 'position-player-1', 'position-player-2', 'position-player-3');
                // Reset manual positioning
                box.style.left = '';
                box.style.top = '';
                box.style.right = '';
                box.style.bottom = '';
                box.style.transform = '';
            }

            sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        }

        const game = new Game();

        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('SW registered: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }

        // Prevent zoom on double tap (iOS)
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        // Prevent pull-to-refresh on mobile
        document.body.addEventListener('touchmove', function(e) {
            if (e.target.closest('.modal-content') || e.target.closest('#bid-input')) {
                return; // Allow scrolling in modals and inputs
            }
            e.preventDefault();
        }, { passive: false });

        function setGameContainerSize() {
            const container = document.querySelector('.game-container');
            if (container) {
                container.style.height = window.innerHeight + 'px';
                container.style.width = window.innerWidth + 'px';
            }
        }
        window.addEventListener('load', setGameContainerSize);
        window.addEventListener('resize', setGameContainerSize);
        window.addEventListener('orientationchange', setGameContainerSize);
        // Call once in case script loads after DOM
        setTimeout(setGameContainerSize, 100);

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registered: ', registration);
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }
    </script>
</body>
</html>
